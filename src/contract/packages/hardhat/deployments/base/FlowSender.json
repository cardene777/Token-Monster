{
  "address": "0x40AcB0E5E5BA146fDb7D124fd00cF55C8A9EE9d6",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokenAddresses",
          "type": "address[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "InvalidTokenAddress",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int96",
          "name": "flowRate",
          "type": "int96"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "StreamCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "StreamDeleted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int96",
          "name": "flowRate",
          "type": "int96"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "StreamUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TokenWrapped",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "accountList",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "int96",
          "name": "flowRate",
          "type": "int96"
        },
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "createStream",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "deleteStream",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "gainWrapToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "readFlowRate",
      "outputs": [
        {
          "internalType": "int96",
          "name": "flowRate",
          "type": "int96"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "superTokens",
      "outputs": [
        {
          "internalType": "contract ISuperToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "int96",
          "name": "flowRate",
          "type": "int96"
        },
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "updateStream",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x4b39eb40ff0d56d1248ee3fac7fd6419768b85fe4471237451e368763474db17",
  "receipt": {
    "to": null,
    "from": "0xA7b547061cA0324BD3357C3bcb01A71071E52E8E",
    "contractAddress": "0x40AcB0E5E5BA146fDb7D124fd00cF55C8A9EE9d6",
    "transactionIndex": 32,
    "gasUsed": "852652",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe36e23359b98a7120a231798c1929e8aeac76a78b204cafbcb97cee647ed583c",
    "transactionHash": "0x4b39eb40ff0d56d1248ee3fac7fd6419768b85fe4471237451e368763474db17",
    "logs": [],
    "blockNumber": 14369689,
    "cumulativeGasUsed": "6920899",
    "status": 1,
    "byzantium": true
  },
  "args": [
    [
      "0x46fd5cfB4c12D87acD3a13e92BAa53240C661D93"
    ]
  ],
  "numDeployments": 1,
  "solcInputHash": "c9a8690c405ad7a0b22bd46d50450e4a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidTokenAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"StreamCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"StreamDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"StreamUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenWrapped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"createStream\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deleteStream\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"gainWrapToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"readFlowRate\",\"outputs\":[{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"superTokens\",\"outputs\":[{\"internalType\":\"contract ISuperToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"int96\",\"name\":\"flowRate\",\"type\":\"int96\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"updateStream\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createStream(address,int96,address)\":{\"details\":\"creates a stream from this contract to desired receiver at desired rate\"},\"deleteStream(address,address)\":{\"details\":\"deletes a stream from this contract to desired receiver\"},\"gainWrapToken(address,uint256)\":{\"details\":\"Wraps the underlying token into its SuperToken equivalent\"},\"readFlowRate(address,address)\":{\"details\":\"get flow rate between this contract to certain receiver\"},\"updateStream(address,int96,address)\":{\"details\":\"updates a stream from this contract to desired receiver to desired rate\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/FlowSender.sol\":\"FlowSender\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\\n     */\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\\n     */\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n}\\n\",\"keccak256\":\"0x79e6094047e40d49efa3c725b7a1519e16c28c46944884b5f6d0fbe89b450f03\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperToken,\\n    IConstantFlowAgreementV1,\\n    IInstantDistributionAgreementV1\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\nimport {\\n    IGeneralDistributionAgreementV1,\\n    ISuperfluidPool,\\n    PoolConfig\\n} from \\\"../interfaces/agreements/gdav1/IGeneralDistributionAgreementV1.sol\\\";\\n\\n/**\\n * @title Library for Token Centric Interface\\n * @author Superfluid\\n * @dev Set `using for ISuperToken` in including file, and call any of these functions on an instance\\n * of ISuperToken.\\n * Note that it is important to \\\"warm up\\\" the cache and cache the host, cfa, ida before calling,\\n * this is only applicable to Foundry tests where the vm.expectRevert() will not work as expected.\\n * You must use vm.startPrank(account) instead of vm.prank when executing functions if the cache\\n * isn't \\\"warmed up\\\" yet. vm.prank impersonates the account only for the first call, which will be\\n * used for caching.\\n */\\nlibrary SuperTokenV1Library {\\n    /** CFA BASE CRUD ************************************* */\\n\\n    /**\\n     * @dev Create flow without userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlow(ISuperToken token, address receiver, int96 flowRate)\\n        internal returns (bool)\\n    {\\n        return createFlow(token, receiver, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The userdata passed along with call\\n     */\\n    function createFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            userData // userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Update flow without userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate)\\n        internal returns (bool)\\n    {\\n        return updateFlow(token, receiver, flowRate, new bytes(0));\\n    }\\n\\n\\n    /**\\n     * @dev Update flow with userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The userdata passed along with call\\n     */\\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Delete flow without userData\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     */\\n    function deleteFlow(ISuperToken token, address sender, address receiver)\\n        internal returns (bool)\\n    {\\n        return deleteFlow(token, sender, receiver, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with userData\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param userData The userdata passed along with call\\n     */\\n    function deleteFlow(ISuperToken token, address sender, address receiver, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /** CFA ACL ************************************* */\\n\\n    /**\\n     * @dev Update permissions for flow operator\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param allowCreate creation permissions\\n     * @param allowCreate update permissions\\n     * @param allowCreate deletion permissions\\n     * @param flowRateAllowance The allowance provided to flowOperator\\n     */\\n    function setFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        bool allowCreate,\\n        bool allowUpdate,\\n        bool allowDelete,\\n        int96 flowRateAllowance\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\\n            | (allowUpdate ? 1 : 0) << 1\\n            | (allowDelete ? 1 : 0) << 2;\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowOperatorPermissions,\\n                (token, flowOperator, permissionsBitmask, flowRateAllowance, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - give operator max permissions\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     */\\n    function setMaxFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.authorizeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - revoke all permission\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     */\\n    function revokeFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.revokeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     */\\n    function increaseFlowRateAllowance(ISuperToken token, address flowOperator, int96 addedFlowRateAllowance)\\n        internal\\n        returns (bool)\\n    {\\n        return increaseFlowRateAllowance(token, flowOperator, addedFlowRateAllowance, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function increaseFlowRateAllowance(\\n        ISuperToken token,\\n        address flowOperator,\\n        int96 addedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(cfa.increaseFlowRateAllowance, (token, flowOperator, addedFlowRateAllowance, new bytes(0))),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is decreased\\n     * @param subtractedFlowRateAllowance amount to decrease allowance by\\n     */\\n    function decreaseFlowRateAllowance(ISuperToken token, address flowOperator, int96 subtractedFlowRateAllowance)\\n        internal\\n        returns (bool)\\n    {\\n        return decreaseFlowRateAllowance(token, flowOperator, subtractedFlowRateAllowance, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is decreased\\n     * @param subtractedFlowRateAllowance amount to decrease allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function decreaseFlowRateAllowance(\\n        ISuperToken token,\\n        address flowOperator,\\n        int96 subtractedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.decreaseFlowRateAllowance, (token, flowOperator, subtractedFlowRateAllowance, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator and adds the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param permissionsToAdd The permissions to add for the flow operator\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     */\\n    function increaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToAdd,\\n        int96 addedFlowRateAllowance\\n    ) internal returns (bool) {\\n        return\\n            increaseFlowRateAllowanceWithPermissions(\\n                token,\\n                flowOperator,\\n                permissionsToAdd,\\n                addedFlowRateAllowance,\\n                new bytes(0)\\n            );\\n    }\\n\\n    /**\\n     * @dev Increases the flow rate allowance for flow operator and adds the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is increased\\n     * @param permissionsToAdd The permissions to add for the flow operator\\n     * @param addedFlowRateAllowance amount to increase allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function increaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToAdd,\\n        int96 addedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.increaseFlowRateAllowanceWithPermissions,\\n                (token, flowOperator, permissionsToAdd, addedFlowRateAllowance, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator and removes the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is subtracted\\n     * @param permissionsToRemove The permissions to remove for the flow operator\\n     * @param subtractedFlowRateAllowance amount to subtract allowance by\\n     */\\n    function decreaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToRemove,\\n        int96 subtractedFlowRateAllowance\\n    ) internal returns (bool) {\\n        return decreaseFlowRateAllowanceWithPermissions(\\n            token, flowOperator, permissionsToRemove, subtractedFlowRateAllowance, new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Decreases the flow rate allowance for flow operator and removes the permissions\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address whose flow rate allowance is subtracted\\n     * @param permissionsToRemove The permissions to remove for the flow operator\\n     * @param subtractedFlowRateAllowance amount to subtract allowance by\\n     * @param userData The userdata passed along with call\\n     */\\n    function decreaseFlowRateAllowanceWithPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        uint8 permissionsToRemove,\\n        int96 subtractedFlowRateAllowance,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.decreaseFlowRateAllowanceWithPermissions,\\n                (token, flowOperator, permissionsToRemove, subtractedFlowRateAllowance, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator in callback\\n     * @notice allowing userData to be a parameter here triggered stack too deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param allowCreate creation permissions\\n     * @param allowCreate update permissions\\n     * @param allowCreate deletion permissions\\n     * @param flowRateAllowance The allowance provided to flowOperator\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function setFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bool allowCreate,\\n        bool allowUpdate,\\n        bool allowDelete,\\n        int96 flowRateAllowance,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\\n            | (allowUpdate ? 1 : 0) << 1\\n            | (allowDelete ? 1 : 0) << 2;\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissionsBitmask,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - give operator max permissions\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function setMaxFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n    * @dev Update permissions for flow operator - revoke all permission\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function revokeFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.revokeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n\\n    /**\\n     * @dev Creates flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate\\n    ) internal returns (bool) {\\n        return createFlowFrom(token, sender, receiver, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Updates flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate\\n    ) internal returns (bool) {\\n        return updateFlowFrom(token, sender, receiver, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n     /**\\n     * @dev Deletes flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     */\\n    function deleteFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver\\n    ) internal returns (bool) {\\n        return deleteFlowFrom(token, sender, receiver, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /** CFA With CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param token The token to flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function createFlowWithCtx(\\n        ISuperToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Create flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function createFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow with context\\n     * @param token The token to flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function updateFlowWithCtx(\\n        ISuperToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The receiver of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function updateFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function deleteFlowWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function deleteFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /** CFA VIEW FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev get flow rate between two accounts for given token\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @return flowRate The flow rate\\n     */\\n    function getFlowRate(ISuperToken token, address sender, address receiver)\\n        internal view returns(int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (, flowRate, , ) = cfa.getFlow(token, sender, receiver);\\n    }\\n\\n    /**\\n     * @dev get flow info between two accounts for given token\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @return lastUpdated Timestamp of flow creation or last flowrate change\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlowInfo(ISuperToken token, address sender, address receiver)\\n        internal view\\n        returns(uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (lastUpdated, flowRate, deposit, owedDeposit) = cfa.getFlow(token, sender, receiver);\\n    }\\n\\n    /**\\n     * @dev get flow info of a distributor to a pool for given token\\n     * @param token The token used in flow\\n     * @param distributor The sitributor of the flow\\n     * @param pool The GDA pool \\n     * @return lastUpdated Timestamp of flow creation or last flowrate change\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     */\\n    function getGDAFlowInfo(ISuperToken token, address distributor, ISuperfluidPool pool)\\n        internal view\\n        returns(uint256 lastUpdated, int96 flowRate, uint256 deposit)\\n    {\\n        (, IGeneralDistributionAgreementV1 gda) = _getHostAndGDA(token);\\n        return gda.getFlow(token, distributor, pool);\\n    }\\n\\n    /* function getGDAFlowInfo(ISuperToken token, address distributor, ISuperfluidPool pool) */\\n    /* { */\\n    /* } */\\n\\n    /**\\n     * @dev get net flow rate for given account for given token (CFA + GDA)\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return flowRate The net flow rate of the account\\n     */\\n    function getNetFlowRate(ISuperToken token, address account)\\n        internal view returns (int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (, IGeneralDistributionAgreementV1 gda) = _getHostAndGDA(token);\\n        int96 cfaNetFlow = cfa.getNetFlow(token, account);\\n        int96 gdaNetFlow = gda.getNetFlow(token, account);\\n        return cfaNetFlow + gdaNetFlow;\\n    }\\n\\n    /**\\n     * @dev get CFA net flow rate for given account for given token\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return flowRate The net flow rate of the account\\n     */\\n    function getCFANetFlowRate(ISuperToken token, address account)\\n        internal view returns (int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getNetFlow(token, account);\\n    }\\n\\n    /**\\n     * @dev get GDA net flow rate for given account for given token\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return flowRate The net flow rate of the account\\n     */\\n    function getGDANetFlowRate(ISuperToken token, address account)\\n        internal view returns (int96 flowRate)\\n    {\\n        (, IGeneralDistributionAgreementV1 gda) = _getHostAndGDA(token);\\n        return gda.getNetFlow(token, account);\\n    }\\n\\n    /**\\n     * @dev get the aggregated flow info of the account (CFA + GDA)\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return lastUpdated Timestamp of the last change of the net flow\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getNetFlowInfo(ISuperToken token, address account)\\n        internal\\n        view\\n        returns (uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (, IGeneralDistributionAgreementV1 gda) = _getHostAndGDA(token);\\n\\n        {\\n            (uint256 lastUpdatedCFA, int96 cfaNetFlowRate, uint256 cfaDeposit, uint256 cfaOwedDeposit) =\\n                cfa.getAccountFlowInfo(token, account);\\n\\n            lastUpdated = lastUpdatedCFA;\\n            flowRate += cfaNetFlowRate;\\n            deposit += cfaDeposit;\\n            owedDeposit += cfaOwedDeposit;\\n        }\\n        \\n        {\\n            (uint256 lastUpdatedGDA, int96 gdaNetFlowRate, uint256 gdaDeposit) = gda.getAccountFlowInfo(token, account);\\n\\n            if (lastUpdatedGDA > lastUpdated) {\\n                lastUpdated = lastUpdatedGDA;\\n            }\\n            flowRate += gdaNetFlowRate;\\n            deposit += gdaDeposit;\\n        }\\n    }\\n\\n    /**\\n     * @dev get the aggregated CFA flow info of the account\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return lastUpdated Timestamp of the last change of the net flow\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getCFANetFlowInfo(ISuperToken token, address account)\\n        internal\\n        view\\n        returns (uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getAccountFlowInfo(token, account);\\n    }\\n\\n    /**\\n     * @dev get the aggregated GDA flow info of the account\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return lastUpdated Timestamp of the last change of the net flow\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getGDANetFlowInfo(ISuperToken token, address account)\\n        internal\\n        view\\n        returns (uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IGeneralDistributionAgreementV1 gda) = _getHostAndGDA(token);\\n        (lastUpdated, flowRate, deposit) = gda.getAccountFlowInfo(token, account);\\n    }\\n\\n    /**\\n     * @dev get the adjustment flow rate for a pool\\n     * @param token Super token address\\n     * @param pool The pool to query\\n     * @return poolAdjustmentFlowRate The adjustment flow rate of the pool\\n     */\\n    function getPoolAdjustmentFlowRate(ISuperToken token, ISuperfluidPool pool)\\n        internal\\n        view\\n        returns (int96 poolAdjustmentFlowRate)\\n    {\\n        (, IGeneralDistributionAgreementV1 gda) = _getHostAndGDA(token);\\n        return gda.getPoolAdjustmentFlowRate(address(pool));\\n    }\\n\\n    /**\\n     * @dev Get the total amount of tokens received by a member via instant and flowing distributions\\n     * @param pool The pool to query\\n     * @param memberAddr The member to query\\n     * @return totalAmountReceived The total amount received by the member\\n     */\\n    function getTotalAmountReceivedByMember(ISuperfluidPool pool, address memberAddr)\\n        internal\\n        view\\n        returns (uint256 totalAmountReceived)\\n    {\\n        return pool.getTotalAmountReceivedByMember(memberAddr);\\n    }\\n\\n    /**\\n     * @notice calculate buffer for a CFA/GDA flow rate\\n     * @dev Even though we are using the CFA, the logic for calculating buffer is the same in the GDA\\n     *      and a change in the buffer logic in either means it is a BREAKING change\\n     * @param token The token used in flow\\n     * @param flowRate The flowrate to calculate the needed buffer for\\n     * @return bufferAmount The buffer amount based on flowRate, liquidationPeriod and minimum deposit\\n     */\\n    function getBufferAmountByFlowRate(ISuperToken token, int96 flowRate) internal view\\n        returns (uint256 bufferAmount)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getDepositRequiredForFlowRate(token, flowRate);\\n    }\\n\\n    /**\\n     * @dev get existing flow permissions\\n     * @param token The token used in flow\\n     * @param sender sender of a flow\\n     * @param flowOperator the address we are checking permissions of for sender & token\\n     * @return allowCreate is true if the flowOperator can create flows\\n     * @return allowUpdate is true if the flowOperator can update flows\\n     * @return allowDelete is true if the flowOperator can delete flows\\n     * @return flowRateAllowance The flow rate allowance the flowOperator is granted (only goes down)\\n     */\\n    function getFlowPermissions(ISuperToken token, address sender, address flowOperator)\\n        internal view\\n        returns (bool allowCreate, bool allowUpdate, bool allowDelete, int96 flowRateAllowance)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        uint8 permissionsBitmask;\\n        (, permissionsBitmask, flowRateAllowance) = cfa.getFlowOperatorData(token, sender, flowOperator);\\n        allowCreate = permissionsBitmask & 1 == 1;\\n        allowUpdate = permissionsBitmask >> 1 & 1 == 1;\\n        allowDelete = permissionsBitmask >> 2 & 1 == 1;\\n    }\\n\\n\\n     /** IDA VIEW FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Gets an index by its ID and publisher.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @return exist True if the index exists.\\n     * @return indexValue Total value of the index.\\n     * @return totalUnitsApproved Units of the index approved by subscribers.\\n     * @return totalUnitsPending Units of teh index not yet approved by subscribers.\\n     */\\n    function getIndex(ISuperToken token, address publisher, uint32 indexId)\\n        internal view\\n        returns (bool exist, uint128 indexValue, uint128 totalUnitsApproved, uint128 totalUnitsPending)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getIndex(token, publisher, indexId);\\n    }\\n\\n    /**\\n     * @dev Calculates the distribution amount based on the amount of tokens desired to distribute.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount of tokens desired to distribute.\\n     * @return actualAmount Amount to be distributed with correct rounding.\\n     * @return newIndexValue The index value after the distribution would be called.\\n     */\\n    function calculateDistribution(ISuperToken token, address publisher, uint32 indexId, uint256 amount)\\n        internal view\\n        returns (uint256 actualAmount, uint128 newIndexValue)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.calculateDistribution(token, publisher, indexId, amount);\\n    }\\n\\n    /**\\n     * @dev List all subscriptions of an address\\n     * @param token Super token used in the indexes listed.\\n     * @param subscriber Subscriber address.\\n     * @return publishers Publishers of the indices.\\n     * @return indexIds IDs of the indices.\\n     * @return unitsList Units owned of the indices.\\n     */\\n    function listSubscriptions(\\n        ISuperToken token,\\n        address subscriber\\n    )\\n        internal view\\n        returns (\\n            address[] memory publishers,\\n            uint32[] memory indexIds,\\n            uint128[] memory unitsList\\n        )\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.listSubscriptions(token, subscriber);\\n    }\\n\\n    /**\\n     * @dev Gets subscription by publisher, index id, and subscriber.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber to the index.\\n     * @return exist True if the subscription exists.\\n     * @return approved True if the subscription has been approved by the subscriber.\\n     * @return units Units held by the subscriber\\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\\n     */\\n    function getSubscription(ISuperToken token, address publisher, uint32 indexId, address subscriber)\\n        internal view\\n        returns (bool exist, bool approved, uint128 units, uint256 pendingDistribution)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getSubscription(token, publisher, indexId, subscriber);\\n    }\\n\\n    /*\\n     * @dev Gets subscription by the agreement ID.\\n     * @param token Super Token used with the index.\\n     * @param agreementId Agreement ID, unique to the subscriber and index ID.\\n     * @return publisher Publisher of the index.\\n     * @return indexId ID of the index.\\n     * @return approved True if the subscription has been approved by the subscriber.\\n     * @return units Units held by the subscriber\\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\\n     */\\n    function getSubscriptionByID(ISuperToken token, bytes32 agreementId)\\n        internal view\\n        returns (\\n            address publisher,\\n            uint32 indexId,\\n            bool approved,\\n            uint128 units,\\n            uint256 pendingDistribution\\n        )\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getSubscriptionByID(token, agreementId);\\n    }\\n\\n    /** GDA VIEW FUNCTIONS ************************************* */\\n    function getFlowDistributionFlowRate(ISuperToken token, address from, ISuperfluidPool to)\\n        internal\\n        view\\n        returns (int96)\\n    {\\n        (, IGeneralDistributionAgreementV1 gda) = _getHostAndGDA(token);\\n        return gda.getFlowRate(token, from, to);\\n    }\\n\\n    function estimateFlowDistributionActualFlowRate(\\n        ISuperToken token,\\n        address from,\\n        ISuperfluidPool to,\\n        int96 requestedFlowRate\\n    ) internal view returns (int96 actualFlowRate, int96 totalDistributionFlowRate) {\\n        (, IGeneralDistributionAgreementV1 gda) = _getHostAndGDA(token);\\n        return gda.estimateFlowDistributionActualFlowRate(token, from, to, requestedFlowRate);\\n    }\\n\\n    function estimateDistributionActualAmount(\\n        ISuperToken token,\\n        address from,\\n        ISuperfluidPool to,\\n        uint256 requestedAmount\\n    ) internal view returns (uint256 actualAmount) {\\n        (, IGeneralDistributionAgreementV1 gda) = _getHostAndGDA(token);\\n        return gda.estimateDistributionActualAmount(token, from, to, requestedAmount);\\n    }\\n\\n    function isMemberConnected(ISuperToken token, address pool, address member) internal view returns (bool) {\\n        (, IGeneralDistributionAgreementV1 gda) = _getHostAndGDA(token);\\n        return gda.isMemberConnected(ISuperfluidPool(pool), member);\\n    }\\n\\n\\n    /** IDA BASE FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Creates a new index.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     */\\n    function createIndex(\\n        ISuperToken token,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        return createIndex(token, indexId, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Creates a new index with userData.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function createIndex(\\n        ISuperToken token,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates an index value. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     */\\n    function updateIndexValue(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue\\n    ) internal returns (bool) {\\n        return updateIndexValue(token, indexId, indexValue, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates an index value with userData. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function updateIndexValue(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of\\n     * passing the new total index value, you pass the amount of tokens desired to be distributed.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount - total number of tokens desired to be distributed\\n     * NOTE in many cases, there can be some precision loss\\n     This may cause a slight difference in the amount param specified and the actual amount distributed.\\n     See below for math:\\n     //indexDelta = amount the index will be updated by during an internal call to _updateIndex().\\n     It is calculated like so:\\n     indexDelta = amount / totalUnits\\n     (see the distribute() implementatation in ./agreements/InstantDistributionAgreement.sol)\\n     * NOTE Solidity does not support floating point numbers\\n     So the indexDelta will be rounded down to the nearest integer.\\n     This will create a 'remainder' amount of tokens that will not be distributed\\n     (we'll call this the 'distribution modulo')\\n     distributionModulo = amount - indexDelta * totalUnits\\n     * NOTE due to rounding, there may be a small amount of tokens left in the publisher's account\\n     This amount is equal to the 'distributionModulo' value\\n     //\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        return distribute(token, indexId, amount, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex` (w user data). Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     */\\n    function approveSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        return approveSubscription(token, publisher, indexId, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index with user data. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function approveSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     */\\n    function revokeSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        return revokeSubscription(token, publisher, indexId, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function revokeSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber holds\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     */\\n    function updateSubscriptionUnits(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units\\n    ) internal returns (bool) {\\n        return updateSubscriptionUnits(token, indexId, subscriber, units, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n     * holds. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function updateSubscriptionUnits(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     */\\n    function deleteSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bool) {\\n        return deleteSubscription(token, publisher, indexId, subscriber, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero. This takes arbitrary userdata.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function deleteSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     */\\n    function claim(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bool) {\\n        return claim(token, publisher, indexId, subscriber, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function claim(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /** IDA WITH CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Creates a new index with ctx.\\n     * Meant for usage in super app callbacks\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function createIndexWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates an index value with ctx. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * Meant for usage in super app callbakcs\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function updateIndexValueWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`.Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function distributeWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function approveSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription. Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function revokeSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n     * holds. Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function updateSubscriptionUnitsWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero.\\n     * Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function deleteSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved.\\n     * Meant for usage in super app callbacks\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function claimWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /** GDA BASE FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Creates a new Superfluid Pool.\\n     * @param token The Super Token address.\\n     * @param admin The pool admin address.\\n     * @param poolConfig The pool configuration (see PoolConfig in IGeneralDistributionAgreementV1.sol)\\n     * @return pool The address of the deployed Superfluid Pool\\n     */\\n    function createPool(ISuperToken token, address admin, PoolConfig memory poolConfig)\\n        internal\\n        returns (ISuperfluidPool pool)\\n    {\\n        (, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        pool = gda.createPool(token, admin, poolConfig);\\n    }\\n\\n    /**\\n     * @dev Updates the units of a pool member.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to update.\\n     * @param memberAddress The address of the member to update.\\n     * @param newUnits The new units of the member.\\n     * @return bool A boolean value indicating whether the pool was created successfully.\\n     */\\n    function updateMemberUnits(ISuperToken token, ISuperfluidPool pool, address memberAddress, uint128 newUnits)\\n        internal\\n        returns (bool)\\n    {\\n        return updateMemberUnits(token, pool, memberAddress, newUnits, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates the units of a pool member.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to update.\\n     * @param memberAddress The address of the member to update.\\n     * @param newUnits The new units of the member.\\n     * @param userData User-specific data.\\n     * @return A boolean value indicating whether the pool was created successfully.\\n     */\\n    function updateMemberUnits(\\n        ISuperToken token,\\n        ISuperfluidPool pool,\\n        address memberAddress,\\n        uint128 newUnits,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        host.callAgreement(\\n            gda, abi.encodeCall(gda.updateMemberUnits, (pool, memberAddress, newUnits, new bytes(0))), userData\\n        );\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Claims all tokens from the pool.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to claim from.\\n     * @param memberAddress The address of the member to claim for.\\n     * @return A boolean value indicating whether the claim was successful.\\n     */\\n    function claimAll(ISuperToken token, ISuperfluidPool pool, address memberAddress) internal returns (bool) {\\n        return claimAll(token, pool, memberAddress, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Claims all tokens from the pool.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to claim from.\\n     * @param memberAddress The address of the member to claim for.\\n     * @param userData User-specific data.\\n     * @return A boolean value indicating whether the claim was successful.\\n     */\\n    function claimAll(ISuperToken token, ISuperfluidPool pool, address memberAddress, bytes memory userData)\\n        internal\\n        returns (bool)\\n    {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        host.callAgreement(gda, abi.encodeCall(gda.claimAll, (pool, memberAddress, new bytes(0))), userData);\\n\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Connects a pool member to `pool`.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to connect.\\n     * @return A boolean value indicating whether the connection was successful.\\n     */\\n    function connectPool(ISuperToken token, ISuperfluidPool pool) internal returns (bool) {\\n        return connectPool(token, pool, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Connects a pool member to `pool`.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to connect.\\n     * @param userData User-specific data.\\n     * @return A boolean value indicating whether the connection was successful.\\n     */\\n    function connectPool(ISuperToken token, ISuperfluidPool pool, bytes memory userData) internal returns (bool) {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        host.callAgreement(gda, abi.encodeCall(gda.connectPool, (pool, new bytes(0))), userData);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Disconnects a pool member from `pool`.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to disconnect.\\n     * @return A boolean value indicating whether the disconnection was successful.\\n     */\\n    function disconnectPool(ISuperToken token, ISuperfluidPool pool) internal returns (bool) {\\n        return disconnectPool(token, pool, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Disconnects a pool member from `pool`.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to disconnect.\\n     * @param userData User-specific data.\\n     * @return A boolean value indicating whether the disconnection was successful.\\n     */\\n    function disconnectPool(ISuperToken token, ISuperfluidPool pool, bytes memory userData) internal returns (bool) {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        host.callAgreement(gda, abi.encodeCall(gda.disconnectPool, (pool, new bytes(0))), userData);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Tries to distribute `requestedAmount` amount of `token` from `from` to `pool`.\\n     * @param token The Super Token address.\\n     * @param from The address from which to distribute tokens.\\n     * @param pool The Superfluid Pool address.\\n     * @param requestedAmount The amount of tokens to distribute.\\n     * @return A boolean value indicating whether the distribution was successful.\\n     */\\n    function distributeToPool(ISuperToken token, address from, ISuperfluidPool pool, uint256 requestedAmount)\\n        internal\\n        returns (bool)\\n    {\\n        return distribute(token, from, pool, requestedAmount, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Tries to distribute `requestedAmount` amount of `token` from `from` to `pool`.\\n     * @param token The Super Token address.\\n     * @param from The address from which to distribute tokens.\\n     * @param pool The Superfluid Pool address.\\n     * @param requestedAmount The amount of tokens to distribute.\\n     * @param userData User-specific data.\\n     * @return A boolean value indicating whether the distribution was successful.\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        address from,\\n        ISuperfluidPool pool,\\n        uint256 requestedAmount,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        host.callAgreement(\\n            gda, abi.encodeCall(gda.distribute, (token, from, pool, requestedAmount, new bytes(0))), userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Tries to distribute flow at `requestedFlowRate` of `token` from `from` to `pool`.\\n     * @param token The Super Token address.\\n     * @param from The address from which to distribute tokens.\\n     * @param pool The Superfluid Pool address.\\n     * @param requestedFlowRate The flow rate of tokens to distribute.\\n     * @return A boolean value indicating whether the distribution was successful.\\n     */\\n    function distributeFlow(ISuperToken token, address from, ISuperfluidPool pool, int96 requestedFlowRate)\\n        internal\\n        returns (bool)\\n    {\\n        return distributeFlow(token, from, pool, requestedFlowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Tries to distribute flow at `requestedFlowRate` of `token` from `from` to `pool`.\\n     * @param token The Super Token address.\\n     * @param from The address from which to distribute tokens.\\n     * @param pool The Superfluid Pool address.\\n     * @param requestedFlowRate The flow rate of tokens to distribute.\\n     * @param userData User-specific data.\\n     * @return A boolean value indicating whether the distribution was successful.\\n     */\\n    function distributeFlow(\\n        ISuperToken token,\\n        address from,\\n        ISuperfluidPool pool,\\n        int96 requestedFlowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        host.callAgreement(\\n            gda, abi.encodeCall(gda.distributeFlow, (token, from, pool, requestedFlowRate, new bytes(0))), userData\\n        );\\n        return true;\\n    }\\n\\n    /** GDA WITH CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Updates the units of a pool member.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to update.\\n     * @param memberAddress The address of the member to update.\\n     * @param newUnits The new units of the member.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function updateMemberUnitsWithCtx(\\n        ISuperToken token,\\n        ISuperfluidPool pool,\\n        address memberAddress,\\n        uint128 newUnits,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        (newCtx,) = host.callAgreementWithContext(\\n            gda,\\n            abi.encodeCall(\\n                gda.updateMemberUnits,\\n                (\\n                    pool,\\n                    memberAddress,\\n                    newUnits,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Claims all tokens from the pool.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to claim from.\\n     * @param memberAddress The address of the member to claim for.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function claimAllWithCtx(ISuperToken token, ISuperfluidPool pool, address memberAddress, bytes memory ctx)\\n        internal\\n        returns (bytes memory newCtx)\\n    {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        (newCtx,) = host.callAgreementWithContext(\\n            gda,\\n            abi.encodeCall(\\n                gda.claimAll,\\n                (\\n                    pool,\\n                    memberAddress,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Connects a pool member to `pool`.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to connect.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function connectPoolWithCtx(ISuperToken token, ISuperfluidPool pool, bytes memory ctx)\\n        internal\\n        returns (bytes memory newCtx)\\n    {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        (newCtx,) = host.callAgreementWithContext(\\n            gda,\\n            abi.encodeCall(\\n                gda.connectPool,\\n                (\\n                    pool,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Disconnects a pool member from `pool`.\\n     * @param token The Super Token address.\\n     * @param pool The Superfluid Pool to disconnect.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function disconnectPoolWithCtx(ISuperToken token, ISuperfluidPool pool, bytes memory ctx)\\n        internal\\n        returns (bytes memory newCtx)\\n    {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        (newCtx,) = host.callAgreementWithContext(\\n            gda,\\n            abi.encodeCall(\\n                gda.disconnectPool,\\n                (\\n                    pool,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Tries to distribute `requestedAmount` amount of `token` from `from` to `pool`.\\n     * @param token The Super Token address.\\n     * @param from The address from which to distribute tokens.\\n     * @param pool The Superfluid Pool address.\\n     * @param requestedAmount The amount of tokens to distribute.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function distributeWithCtx(\\n        ISuperToken token,\\n        address from,\\n        ISuperfluidPool pool,\\n        uint256 requestedAmount,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        (newCtx,) = host.callAgreementWithContext(\\n            gda,\\n            abi.encodeCall(\\n                gda.distribute,\\n                (\\n                    token,\\n                    from,\\n                    pool,\\n                    requestedAmount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Tries to distribute flow at `requestedFlowRate` of `token` from `from` to `pool`.\\n     * @param token The Super Token address.\\n     * @param from The address from which to distribute tokens.\\n     * @param pool The Superfluid Pool address.\\n     * @param requestedFlowRate The flow rate of tokens to distribute.\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The updated context after the execution of the agreement function\\n     */\\n    function distributeFlowWithCtx(\\n        ISuperToken token,\\n        address from,\\n        ISuperfluidPool pool,\\n        int96 requestedFlowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IGeneralDistributionAgreementV1 gda) = _getAndCacheHostAndGDA(token);\\n        (newCtx,) = host.callAgreementWithContext(\\n            gda,\\n            abi.encodeCall(\\n                gda.distributeFlow,\\n                (\\n                    token,\\n                    from,\\n                    pool,\\n                    requestedFlowRate,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    // ************** private helpers **************\\n\\n    // @note We must use hardcoded constants here because:\\n    // Only direct number constants and references to such constants are supported by inline assembly.\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.host\\\")\\n    bytes32 private constant _HOST_SLOT = 0x65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.cfa\\\")\\n    bytes32 private constant _CFA_SLOT = 0xb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.ida\\\");\\n    bytes32 private constant _IDA_SLOT = 0xa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.gda\\\");\\n    bytes32 private constant _GDA_SLOT = 0xc36f6c05164a669ecb6da53e218d77ae44d51cfc99f91e5a125a18de0949bee4;\\n\\n    // gets the host and cfa addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndCFA(ISuperToken token)\\n        private\\n        returns (ISuperfluid host, IConstantFlowAgreementV1 cfa)\\n    {\\n        // check if already in contract storage...\\n        assembly {\\n            // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            cfa := sload(_CFA_SLOT)\\n        }\\n        if (address(cfa) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n\\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"))));\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n                // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_CFA_SLOT, cfa)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(cfa) != address(0));\\n    }\\n\\n    // gets the host and ida addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndIDA(ISuperToken token)\\n        private\\n        returns (ISuperfluid host, IInstantDistributionAgreementV1 ida)\\n    {\\n        // check if already in contract storage...\\n        assembly {\\n            // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            ida := sload(_IDA_SLOT)\\n        }\\n        if (address(ida) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\"))));\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n                // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_IDA_SLOT, ida)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(ida) != address(0));\\n    }\\n\\n    // gets the host and gda addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndGDA(ISuperToken token)\\n        private\\n        returns (ISuperfluid host, IGeneralDistributionAgreementV1 gda)\\n    {\\n        // check if already in contract storage...\\n        assembly {\\n            // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            gda := sload(_GDA_SLOT)\\n        }\\n        if (address(gda) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            gda = IGeneralDistributionAgreementV1(\\n                address(\\n                    ISuperfluid(host).getAgreementClass(\\n                        keccak256(\\\"org.superfluid-finance.agreements.GeneralDistributionAgreement.v1\\\")\\n                    )\\n                )\\n            );\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n                // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_GDA_SLOT, gda)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(gda) != address(0));\\n    }\\n\\n    // gets the host and cfa addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndCFA(ISuperToken token) private view returns (ISuperfluid host, IConstantFlowAgreementV1 cfa) {\\n        // check if already in contract storage...\\n        assembly {\\n            // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            cfa := sload(_CFA_SLOT)\\n        }\\n        if (address(cfa) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"))));\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(cfa) != address(0));\\n    }\\n\\n    // gets the host and ida addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndIDA(ISuperToken token)\\n        private\\n        view\\n        returns (ISuperfluid host, IInstantDistributionAgreementV1 ida)\\n    {\\n        // check if already in contract storage...\\n        assembly {\\n            // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            ida := sload(_IDA_SLOT)\\n        }\\n        if (address(ida) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\"))));\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(ida) != address(0));\\n    }\\n\\n    // gets the host and gda addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndGDA(ISuperToken token)\\n        private\\n        view\\n        returns (ISuperfluid host, IGeneralDistributionAgreementV1 gda)\\n    {\\n        // check if already in contract storage...\\n        assembly {\\n            // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            gda := sload(_GDA_SLOT)\\n        }\\n        if (address(gda) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            gda = IGeneralDistributionAgreementV1(\\n                address(\\n                    ISuperfluid(host).getAgreementClass(\\n                        keccak256(\\\"org.superfluid-finance.agreements.GeneralDistributionAgreement.v1\\\")\\n                    )\\n                )\\n            );\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(gda) != address(0));\\n    }\\n}\\n\",\"keccak256\":\"0xb110982f389abbb9c12dc485e71797ea8c9f52a14bd1f5a51f2118c495f2e68d\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Constant Flow Agreement interface\\n * @author Superfluid\\n */\\nabstract contract IConstantFlowAgreementV1 is ISuperAgreement {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error CFA_ACL_NO_SENDER_CREATE();               // 0x4b993136\\n    error CFA_ACL_NO_SENDER_UPDATE();               // 0xedfa0d3b\\n    error CFA_ACL_OPERATOR_NO_CREATE_PERMISSIONS(); // 0xa3eab6ac\\n    error CFA_ACL_OPERATOR_NO_UPDATE_PERMISSIONS(); // 0xac434b5f\\n    error CFA_ACL_OPERATOR_NO_DELETE_PERMISSIONS(); // 0xe30f1bff\\n    error CFA_ACL_FLOW_RATE_ALLOWANCE_EXCEEDED();   // 0xa0645c1f\\n    error CFA_ACL_UNCLEAN_PERMISSIONS();            // 0x7939d66c\\n    error CFA_ACL_NO_SENDER_FLOW_OPERATOR();        // 0xb0ed394d\\n    error CFA_ACL_NO_NEGATIVE_ALLOWANCE();          // 0x86e0377d\\n    error CFA_FLOW_ALREADY_EXISTS();                // 0x801b6863\\n    error CFA_FLOW_DOES_NOT_EXIST();                // 0x5a32bf24\\n    error CFA_INSUFFICIENT_BALANCE();               // 0xea76c9b3\\n    error CFA_ZERO_ADDRESS_SENDER();                // 0x1ce9b067\\n    error CFA_ZERO_ADDRESS_RECEIVER();              // 0x78e02b2a\\n    error CFA_HOOK_OUT_OF_GAS();                    // 0x9f76430b\\n    error CFA_DEPOSIT_TOO_BIG();                    // 0x752c2b9c\\n    error CFA_FLOW_RATE_TOO_BIG();                  // 0x0c9c55c1\\n    error CFA_NON_CRITICAL_SENDER();                // 0xce11b5d1\\n    error CFA_INVALID_FLOW_RATE();                  // 0x91acad16\\n    error CFA_NO_SELF_FLOW();                       // 0xa47338ef\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\");\\n    }\\n\\n    /**\\n     * @notice Get the maximum flow rate allowed with the deposit\\n     * @dev The deposit is clipped and rounded down\\n     * @param deposit Deposit amount used for creating the flow\\n     * @return flowRate The maximum flow rate\\n     */\\n    function getMaximumFlowRateFromDeposit(\\n        ISuperfluidToken token,\\n        uint256 deposit)\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Get the deposit required for creating the flow\\n     * @dev Calculates the deposit based on the liquidationPeriod and flowRate\\n     * @param flowRate Flow rate to be tested\\n     * @return deposit The deposit amount based on flowRate and liquidationPeriod\\n     * @custom:note\\n     * - if calculated deposit (flowRate * liquidationPeriod) is less\\n     *   than the minimum deposit, we use the minimum deposit otherwise\\n     *   we use the calculated deposit\\n     */\\n    function getDepositRequiredForFlowRate(\\n        ISuperfluidToken token,\\n        int96 flowRate)\\n        external view virtual\\n        returns (uint256 deposit);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on host.getNow()\\n     * @param account The account we are interested in\\n     * @return isCurrentlyPatricianPeriod Whether it is currently the patrician period dictated by governance\\n     * @return timestamp The value of host.getNow()\\n     */\\n    function isPatricianPeriodNow(\\n        ISuperfluidToken token,\\n        address account)\\n        external view virtual\\n        returns (bool isCurrentlyPatricianPeriod, uint256 timestamp);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on timestamp\\n     * @param account The account we are interested in\\n     * @param timestamp The timestamp we are interested in observing the result of isPatricianPeriod\\n     * @return bool Whether it is currently the patrician period dictated by governance\\n     */\\n    function isPatricianPeriod(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 timestamp\\n    )\\n        public view virtual\\n        returns (bool);\\n\\n    /**\\n     * @dev msgSender from `ctx` updates permissions for the `flowOperator` with `flowRateAllowance`\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissions A bitmask representation of the granted permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowOperatorPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice msgSender from `ctx` increases flow rate allowance for the `flowOperator` by `addedFlowRateAllowance`\\n     * @dev if `addedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param addedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function increaseFlowRateAllowance(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        int96 addedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` decreases flow rate allowance for the `flowOperator` by `subtractedFlowRateAllowance`\\n     * @dev if `subtractedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param subtractedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function decreaseFlowRateAllowance(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        int96 subtractedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` increases flow rate allowance for the `flowOperator` by `addedFlowRateAllowance`\\n     * @dev if `addedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissionsToAdd A bitmask representation of the granted permissions to add as a delta\\n     * @param addedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function increaseFlowRateAllowanceWithPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissionsToAdd,\\n        int96 addedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` decreases flow rate allowance for the `flowOperator` by `subtractedFlowRateAllowance`\\n     * @dev if `subtractedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissionsToRemove A bitmask representation of the granted permissions to remove as a delta\\n     * @param subtractedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function decreaseFlowRateAllowanceWithPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissionsToRemove,\\n        int96 subtractedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` grants `flowOperator` all permissions with flowRateAllowance as type(int96).max\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n     /**\\n     * @notice msgSender from `ctx` revokes `flowOperator` create/update/delete permissions\\n     * @dev `permissions` and `flowRateAllowance` will both be set to 0\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Get the permissions of a flow operator between `sender` and `flowOperator` for `token`\\n     * @param token Super token address\\n     * @param sender The permission granter address\\n     * @param flowOperator The permission grantee address\\n     * @return flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorData(\\n       ISuperfluidToken token,\\n       address sender,\\n       address flowOperator\\n    )\\n        public view virtual\\n        returns (\\n            bytes32 flowOperatorId,\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Get flow operator using flowOperatorId\\n     * @param token Super token address\\n     * @param flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorDataByID(\\n       ISuperfluidToken token,\\n       bytes32 flowOperatorId\\n    )\\n        external view virtual\\n        returns (\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Create a flow betwen ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks\\n     * - AgreementCreated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note\\n     * - A deposit is taken as safety margin for the solvency agents\\n     * - A extra gas fee may be taken to pay for solvency agent liquidations\\n     */\\n    function createFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Create a flow between sender and receiver\\n    * @dev A flow created by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function createFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Update the flow rate between ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks\\n     * - AgreementUpdated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note\\n     * - Only the flow sender may update the flow rate\\n     * - Even if the flow rate is zero, the flow is not deleted\\n     * from the system\\n     * - Deposit amount will be adjusted accordingly\\n     * - No new gas fee is charged\\n     */\\n    function updateFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Update a flow between sender and receiver\\n    * @dev A flow updated by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function updateFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Get the flow data between `sender` and `receiver` of `token`\\n     * @param token Super token address\\n     * @param sender Flow sender\\n     * @param receiver Flow receiver\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @notice Get flow data using agreementId\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The deposit amount of the flow\\n     * @return owedDeposit The owed deposit amount of the flow\\n     */\\n    function getFlowByID(\\n       ISuperfluidToken token,\\n       bytes32 agreementId\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @dev Get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return timestamp Timestamp of when a flow was last updated for account\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getAccountFlowInfo(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @dev Get the net flow rate of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return flowRate Net flow rate\\n     */\\n    function getNetFlow(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     *\\n     * @custom:callbacks\\n     * - AgreementTerminated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note\\n     * - Both flow sender and receiver may delete the flow\\n     * - If Sender account is insolvent or in critical state, a solvency agent may\\n     *   also terminate the agreement\\n     * - Gas fee may be returned to the sender\\n     */\\n    function deleteFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev A flow deleted by an approved flow operator (see above for details on callbacks)\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     */\\n    function deleteFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Flow operator updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param flowOperator Flow operator address\\n     * @param permissions Octo bitmask representation of permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    event FlowOperatorUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    );\\n\\n    /**\\n     * @dev Flow updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param receiver Flow recipient address\\n     * @param flowRate Flow rate in amount per second for this flow\\n     * @param totalSenderFlowRate Total flow rate in amount per second for the sender\\n     * @param totalReceiverFlowRate Total flow rate in amount per second for the receiver\\n     * @param userData The user provided data\\n     *\\n     */\\n    event FlowUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed receiver,\\n        int96 flowRate,\\n        int256 totalSenderFlowRate,\\n        int256 totalReceiverFlowRate,\\n        bytes userData\\n    );\\n\\n    /**\\n     * @dev Flow updated extension event\\n     * @param flowOperator Flow operator address - the Context.msgSender\\n     * @param deposit The deposit amount for the stream\\n     */\\n    event FlowUpdatedExtension(\\n        address indexed flowOperator,\\n        uint256 deposit\\n    );\\n}\\n\",\"keccak256\":\"0x26f6828c29d0a4f58d9427dabcb0ad6c0ab2e3e8b2ce97bf25846cff740a8968\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Instant Distribution Agreement interface\\n * @author Superfluid\\n *\\n * @notice \\n *   - A publisher can create as many as indices as possibly identifiable with `indexId`.\\n *     - `indexId` is deliberately limited to 32 bits, to avoid the chance for sha-3 collision.\\n *       Despite knowing sha-3 collision is only theoretical.\\n *   - A publisher can create a subscription to an index for any subscriber.\\n *   - A subscription consists of:\\n *     - The index it subscribes to.\\n *     - Number of units subscribed.\\n *   - An index consists of:\\n *     - Current value as `uint128 indexValue`.\\n *     - Total units of the approved subscriptions as `uint128 totalUnitsApproved`.\\n *     - Total units of the non approved subscription as `uint128 totalUnitsPending`.\\n *   - A publisher can update an index with a new value that doesn't decrease.\\n *   - A publisher can update a subscription with any number of units.\\n *   - A publisher or a subscriber can delete a subscription and reset its units to zero.\\n *   - A subscriber must approve the index in order to receive distributions from the publisher\\n *     each time the index is updated.\\n *     - The amount distributed is $$\\\\Delta{index} * units$$\\n *   - Distributions to a non approved subscription stays in the publisher's deposit until:\\n *     - the subscriber approves the subscription (side effect),\\n *     - the publisher updates the subscription (side effect),\\n *     - the subscriber deletes the subscription even if it is never approved (side effect),\\n *     - or the subscriber can explicitly claim them.\\n */\\nabstract contract IInstantDistributionAgreementV1 is ISuperAgreement {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error IDA_INDEX_SHOULD_GROW();             // 0xcfdca725\\n    error IDA_OPERATION_NOT_ALLOWED();         // 0x92da6d17\\n    error IDA_INDEX_ALREADY_EXISTS();          // 0x5c02a517\\n    error IDA_INDEX_DOES_NOT_EXIST();          // 0xedeaa63b\\n    error IDA_SUBSCRIPTION_DOES_NOT_EXIST();   // 0xb6c8c980\\n    error IDA_SUBSCRIPTION_ALREADY_APPROVED(); // 0x3eb2f849\\n    error IDA_SUBSCRIPTION_IS_NOT_APPROVED();  // 0x37412573\\n    error IDA_INSUFFICIENT_BALANCE();          // 0x16e759bb\\n    error IDA_ZERO_ADDRESS_SUBSCRIBER();       // 0xc90a4674\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\");\\n    }\\n\\n    /**************************************************************************\\n     * Index operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Create a new index for the publisher\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function createIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n    * @dev Index created event\\n    * @param token Super token address\\n    * @param publisher Index creator and publisher\\n    * @param indexId The specified indexId of the newly created index\\n    * @param userData The user provided data\\n    */\\n    event IndexCreated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Query the data of a index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @return exist Does the index exist\\n     * @return indexValue Value of the current index\\n     * @return totalUnitsApproved Total units approved for the index\\n     * @return totalUnitsPending Total units pending approval for the index\\n     */\\n    function getIndex(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                uint128 indexValue,\\n                uint128 totalUnitsApproved,\\n                uint128 totalUnitsPending);\\n\\n    /**\\n     * @dev Calculate actual distribution amount\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @return actualAmount The amount to be distributed after ensuring no rounding errors\\n     * @return newIndexValue The index value given the desired amount of tokens to be distributed\\n     */\\n    function calculateDistribution(\\n       ISuperfluidToken token,\\n       address publisher,\\n       uint32 indexId,\\n       uint256 amount)\\n           external view\\n           virtual\\n           returns(\\n               uint256 actualAmount,\\n               uint128 newIndexValue);\\n\\n    /**\\n     * @dev Update index value of an index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param indexValue Value of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function updateIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index updated event\\n      * @param token Super token address\\n      * @param publisher Index updater and publisher\\n      * @param indexId The specified indexId of the updated index\\n      * @param oldIndexValue The previous index value\\n      * @param newIndexValue The updated index value\\n      * @param totalUnitsPending The total units pending when the indexValue was updated\\n      * @param totalUnitsApproved The total units approved when the indexValue was updated\\n      * @param userData The user provided data\\n      */\\n    event IndexUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        uint128 oldIndexValue,\\n        uint128 newIndexValue,\\n        uint128 totalUnitsPending,\\n        uint128 totalUnitsApproved,\\n        bytes userData);\\n\\n    /**\\n     * @dev Distribute tokens through the index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:note \\n     * - This is a convenient version of updateIndex. It adds to the index\\n     *   a delta that equals to `amount / totalUnits`\\n     * - The actual amount distributed could be obtained via\\n     *   `calculateDistribution`. This is due to precision error with index\\n     *   value and units data range\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function distribute(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n\\n    /**************************************************************************\\n     * Subscription operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Approve the subscription of an index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     */\\n    function approveSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index subscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The approved subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexSubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n\\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionApproved(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n    * @notice Revoke the subscription of an index\\n    * @dev \\\"Unapproves\\\" the subscription and moves approved units to pending\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function revokeSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n         external\\n         virtual\\n         returns(bytes memory newCtx);\\n    /**\\n      * @dev Index unsubscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The unsubscribed subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexUnsubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionRevoked(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Update the nuber of units of a subscription\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @param units Number of units of the subscription\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function updateSubscription(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n      * @dev Index units updated event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event IndexUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription units updated event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param indexId The specified indexId\\n      * @param publisher Index publisher\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint128 units,\\n        bytes userData);\\n\\n    /**\\n     * @dev Get data of a subscription\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @return exist Does the subscription exist?\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @notice Get data of a subscription by agreement ID\\n     * @dev indexId (agreementId) is the keccak256 hash of encodePacked(\\\"publisher\\\", publisher, indexId)\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return publisher The publisher of the index\\n     * @return indexId Id of the index\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscriptionByID(\\n        ISuperfluidToken token,\\n        bytes32 agreementId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address publisher,\\n                uint32 indexId,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @dev List subscriptions of an user\\n     * @param token Super token address\\n     * @param subscriber The subscriber's address\\n     * @return publishers Publishers of the subcriptions\\n     * @return indexIds Indexes of the subscriptions\\n     * @return unitsList Units of the subscriptions\\n     */\\n    function listSubscriptions(\\n        ISuperfluidToken token,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address[] memory publishers,\\n                uint32[] memory indexIds,\\n                uint128[] memory unitsList);\\n\\n    /**\\n     * @dev Delete the subscription of an user\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber's address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if the subscriber called it\\n     *   - AgreementTerminated callback to the publsiher:\\n     *      - agreementId is for the subscription\\n     * - if the publisher called it\\n     *   - AgreementTerminated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function deleteSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n    * @dev Claim pending distributions\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param subscriber The subscriber's address\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:note The subscription should not be approved yet\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function claim(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n        external\\n        virtual\\n        returns(bytes memory newCtx);\\n    \\n    /**\\n      * @dev Index distribution claimed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param amount The pending amount claimed\\n      */\\n    event IndexDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint256 amount);\\n    \\n    /**\\n      * @dev Subscription distribution claimed event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param amount The pending amount claimed\\n      */\\n    event SubscriptionDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint256 amount);\\n\\n}\\n\",\"keccak256\":\"0xac0ea75673feea931d1129ffff440390a0dd3a8f8cfa60fdb1481342652dc348\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/gdav1/IGeneralDistributionAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >=0.8.4;\\n\\nimport { ISuperAgreement } from \\\"../../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../../superfluid/ISuperfluidToken.sol\\\";\\nimport { ISuperfluidPool } from \\\"../../agreements/gdav1/ISuperfluidPool.sol\\\";\\n\\nstruct PoolConfig {\\n    /// @dev if true, the pool members can transfer their owned units\\n    /// else, only the pool admin can manipulate the units for pool members\\n    bool transferabilityForUnitsOwner;\\n    /// @dev if true, anyone can execute distributions via the pool\\n    /// else, only the pool admin can execute distributions via the pool\\n    bool distributionFromAnyAddress;\\n}\\n\\n/**\\n * @title General Distribution Agreement interface\\n * @author Superfluid\\n */\\nabstract contract IGeneralDistributionAgreementV1 is ISuperAgreement {\\n\\n    // Custom Errors\\n    error GDA_DISTRIBUTE_FOR_OTHERS_NOT_ALLOWED();          // 0xf67d263e\\n    error GDA_DISTRIBUTE_FROM_ANY_ADDRESS_NOT_ALLOWED();    // 0x7761a5e5\\n    error GDA_FLOW_DOES_NOT_EXIST();                        // 0x29f4697e\\n    error GDA_NON_CRITICAL_SENDER();                        // 0x666f381d\\n    error GDA_INSUFFICIENT_BALANCE();                       // 0x33115c3f\\n    error GDA_NO_NEGATIVE_FLOW_RATE();                      // 0x15f25663\\n    error GDA_ADMIN_CANNOT_BE_POOL();                       // 0x9ab88a26\\n    error GDA_NOT_POOL_ADMIN();                             // 0x3a87e565\\n    error GDA_NO_ZERO_ADDRESS_ADMIN();                      // 0x82c5d837\\n    error GDA_ONLY_SUPER_TOKEN_POOL();                      // 0x90028c37\\n\\n\\n    // Events\\n    event InstantDistributionUpdated(\\n        ISuperfluidToken indexed token,\\n        ISuperfluidPool indexed pool,\\n        address indexed distributor,\\n        address operator,\\n        uint256 requestedAmount,\\n        uint256 actualAmount,\\n        bytes userData\\n    );\\n\\n    event FlowDistributionUpdated(\\n        ISuperfluidToken indexed token,\\n        ISuperfluidPool indexed pool,\\n        address indexed distributor,\\n        // operator's have permission to liquidate critical flows\\n        // on behalf of others\\n        address operator,\\n        int96 oldFlowRate,\\n        int96 newDistributorToPoolFlowRate,\\n        int96 newTotalDistributionFlowRate,\\n        address adjustmentFlowRecipient,\\n        int96 adjustmentFlowRate,\\n        bytes userData\\n    );\\n\\n    event PoolCreated(ISuperfluidToken indexed token, address indexed admin, ISuperfluidPool pool);\\n\\n    event PoolConnectionUpdated(\\n        ISuperfluidToken indexed token,\\n        ISuperfluidPool indexed pool,\\n        address indexed account,\\n        bool connected,\\n        bytes userData\\n    );\\n\\n    event BufferAdjusted(\\n        ISuperfluidToken indexed token,\\n        ISuperfluidPool indexed pool,\\n        address indexed from,\\n        int256 bufferDelta,\\n        uint256 newBufferAmount,\\n        uint256 totalBufferAmount\\n    );\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external pure override returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.GeneralDistributionAgreement.v1\\\");\\n    }\\n\\n    /// @dev Gets the GDA net flow rate of `account` for `token`.\\n    /// @param token The token address\\n    /// @param account The account address\\n    /// @return net flow rate\\n    function getNetFlow(ISuperfluidToken token, address account) external view virtual returns (int96);\\n\\n    /// @notice Gets the GDA flow rate of `from` to `to` for `token`.\\n    /// @dev This is primarily used to get the flow distribution flow rate from a distributor to a pool or the\\n    /// adjustment flow rate of a pool.\\n    /// @param token The token address\\n    /// @param from The sender address\\n    /// @param to The receiver address (the pool)\\n    /// @return flow rate\\n    function getFlowRate(ISuperfluidToken token, address from, ISuperfluidPool to)\\n        external\\n        view\\n        virtual\\n        returns (int96);\\n\\n    /// @dev Gets the GDA flow data between `from` and `to` of `token`\\n    /// @param token The token address\\n    /// @param from The sender address\\n    /// @param to The receiver address\\n    /// @return lastUpdated The timestamp of when the flow was last updated\\n    /// @return flowRate The flow rate\\n    /// @return deposit The amount of deposit the flow\\n    function getFlow(ISuperfluidToken token, address from, ISuperfluidPool to)\\n        external\\n        view\\n        virtual\\n        returns (uint256 lastUpdated, int96 flowRate, uint256 deposit);\\n\\n    /// @dev Gets the aggregated GDA flow info of `account` for `token`\\n    /// @param token The token address\\n    /// @param account The account address\\n    /// @return timestamp The timestamp of when the flow was last updated for account\\n    /// @return flowRate The net flow rate of token for account\\n    /// @return deposit The sum of all deposits for account's flows\\n    function getAccountFlowInfo(ISuperfluidToken token, address account)\\n        external\\n        view\\n        virtual\\n        returns (uint256 timestamp, int96 flowRate, uint256 deposit);\\n\\n    /// @notice Executes an optimistic estimation of what the actual flow distribution flow rate may be.\\n    /// The actual flow distribution flow rate is the flow rate that will be sent from `from`.\\n    /// NOTE: this is only precise in an atomic transaction. DO NOT rely on this if querying off-chain.\\n    /// @dev The difference between the requested flow rate and the actual flow rate is the adjustment flow rate,\\n    /// this adjustment flow rate goes to the pool admin.\\n    /// @param token The token address\\n    /// @param from The sender address\\n    /// @param to The pool address\\n    /// @param requestedFlowRate The requested flow rate\\n    /// @return actualFlowRate and totalDistributionFlowRate\\n    function estimateFlowDistributionActualFlowRate(\\n        ISuperfluidToken token,\\n        address from,\\n        ISuperfluidPool to,\\n        int96 requestedFlowRate\\n    ) external view virtual returns (int96 actualFlowRate, int96 totalDistributionFlowRate);\\n\\n    /// @notice Executes an optimistic estimation of what the actual amount distributed may be.\\n    /// The actual amount distributed is the amount that will be sent from `from`.\\n    /// NOTE: this is only precise in an atomic transaction. DO NOT rely on this if querying off-chain.\\n    /// @dev The difference between the requested amount and the actual amount is the adjustment amount.\\n    /// @param token The token address\\n    /// @param from The sender address\\n    /// @param to The pool address\\n    /// @param requestedAmount The requested amount\\n    /// @return actualAmount\\n    function estimateDistributionActualAmount(\\n        ISuperfluidToken token,\\n        address from,\\n        ISuperfluidPool to,\\n        uint256 requestedAmount\\n    ) external view virtual returns (uint256 actualAmount);\\n\\n    /// @notice Gets the adjustment flow rate of `pool` for `token`.\\n    /// @param pool The pool address\\n    /// @return adjustment flow rate\\n    function getPoolAdjustmentFlowRate(address pool) external view virtual returns (int96);\\n\\n    ////////////////////////////////////////////////////////////////////////////////\\n    // Pool Operations\\n    ////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Creates a new pool for `token` where the admin is `admin`.\\n    /// @param token The token address\\n    /// @param admin The admin of the pool\\n    /// @param poolConfig The pool configuration (see PoolConfig struct)\\n    function createPool(ISuperfluidToken token, address admin, PoolConfig memory poolConfig)\\n        external\\n        virtual\\n        returns (ISuperfluidPool pool);\\n\\n    function updateMemberUnits(ISuperfluidPool pool, address memberAddress, uint128 newUnits, bytes calldata ctx)\\n        external\\n        virtual\\n        returns (bytes memory newCtx);\\n\\n    function claimAll(ISuperfluidPool pool, address memberAddress, bytes calldata ctx)\\n        external\\n        virtual\\n        returns (bytes memory newCtx);\\n\\n    /// @notice Connects `msg.sender` to `pool`.\\n    /// @dev This is used to connect a pool to the GDA.\\n    /// @param pool The pool address\\n    /// @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    /// @return newCtx the new context bytes\\n    function connectPool(ISuperfluidPool pool, bytes calldata ctx) external virtual returns (bytes memory newCtx);\\n\\n    /// @notice Disconnects `msg.sender` from `pool`.\\n    /// @dev This is used to disconnect a pool from the GDA.\\n    /// @param pool The pool address\\n    /// @param ctx Context bytes (see ISuperfluidPoolAdmin for Context struct)\\n    /// @return newCtx the new context bytes\\n    function disconnectPool(ISuperfluidPool pool, bytes calldata ctx) external virtual returns (bytes memory newCtx);\\n\\n    /// @notice Checks whether `account` is a pool.\\n    /// @param token The token address\\n    /// @param account The account address\\n    /// @return true if `account` is a pool\\n    function isPool(ISuperfluidToken token, address account) external view virtual returns (bool);\\n\\n    /// Check if an address is connected to the pool\\n    function isMemberConnected(ISuperfluidPool pool, address memberAddr) external view virtual returns (bool);\\n\\n    /// Get pool adjustment flow information: (recipient, flowHash, flowRate)\\n    function getPoolAdjustmentFlowInfo(ISuperfluidPool pool) external view virtual returns (address, bytes32, int96);\\n\\n    ////////////////////////////////////////////////////////////////////////////////\\n    // Agreement Operations\\n    ////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Tries to distribute `requestedAmount` of `token` from `from` to `pool`.\\n    /// @dev NOTE: The actual amount distributed may differ.\\n    /// @param token The token address\\n    /// @param from The sender address\\n    /// @param pool The pool address\\n    /// @param requestedAmount The requested amount\\n    /// @param ctx Context bytes (see ISuperfluidPool for Context struct)\\n    /// @return newCtx the new context bytes\\n    function distribute(\\n        ISuperfluidToken token,\\n        address from,\\n        ISuperfluidPool pool,\\n        uint256 requestedAmount,\\n        bytes calldata ctx\\n    ) external virtual returns (bytes memory newCtx);\\n\\n    /// @notice Tries to distributeFlow `requestedFlowRate` of `token` from `from` to `pool`.\\n    /// @dev NOTE: The actual distribution flow rate may differ.\\n    /// @param token The token address\\n    /// @param from The sender address\\n    /// @param pool The pool address\\n    /// @param requestedFlowRate The requested flow rate\\n    /// @param ctx Context bytes (see ISuperfluidPool for Context struct)\\n    /// @return newCtx the new context bytes\\n    function distributeFlow(\\n        ISuperfluidToken token,\\n        address from,\\n        ISuperfluidPool pool,\\n        int96 requestedFlowRate,\\n        bytes calldata ctx\\n    ) external virtual returns (bytes memory newCtx);\\n\\n    ////////////////////////////////////////////////////////////////////////////////\\n    // Solvency Functions\\n    ////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on host.getNow()\\n     * @param account The account we are interested in\\n     * @return isCurrentlyPatricianPeriod Whether it is currently the patrician period dictated by governance\\n     * @return timestamp The value of host.getNow()\\n     */\\n    function isPatricianPeriodNow(ISuperfluidToken token, address account)\\n        external\\n        view\\n        virtual\\n        returns (bool isCurrentlyPatricianPeriod, uint256 timestamp);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on timestamp\\n     * @param account The account we are interested in\\n     * @param timestamp The timestamp we are interested in observing the result of isPatricianPeriod\\n     * @return bool Whether it is currently the patrician period dictated by governance\\n     */\\n    function isPatricianPeriod(ISuperfluidToken token, address account, uint256 timestamp)\\n        public\\n        view\\n        virtual\\n        returns (bool);\\n}\\n\",\"keccak256\":\"0x2453b6e031f02e22acbec1d70746e2294b27dd19138b925c0e638ab70a73f4dc\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/gdav1/IPoolAdminNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { IPoolNFTBase } from \\\"./IPoolNFTBase.sol\\\";\\n\\ninterface IPoolAdminNFT is IPoolNFTBase {\\n    // PoolAdminNFTData struct storage packing:\\n    // b = bits\\n    // WORD 1: | pool   | FREE\\n    //         | 160b   | 96b\\n    // WORD 2: | admin  | FREE\\n    //         | 160b   | 96b\\n    struct PoolAdminNFTData {\\n        address pool;\\n        address admin;\\n    }\\n\\n    /// Write Functions ///\\n    function mint(address pool) external;\\n\\n    function poolAdminDataByTokenId(uint256 tokenId) external view returns (PoolAdminNFTData memory data);\\n}\",\"keccak256\":\"0x114cbccfd652231eb5454ab9c4cfe0d3a7427943dee0cce72d88160f12ed8505\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/gdav1/IPoolMemberNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { IPoolNFTBase } from \\\"./IPoolNFTBase.sol\\\";\\n\\ninterface IPoolMemberNFT is IPoolNFTBase {\\n    // PoolMemberNFTData struct storage packing:\\n    // b = bits\\n    // WORD 1: | pool   | FREE\\n    //         | 160b   | 96b\\n    // WORD 2: | member | FREE\\n    //         | 160b   | 96b\\n    // WORD 3: | units  | FREE\\n    //         | 128b   | 128b\\n    struct PoolMemberNFTData {\\n        address pool;\\n        address member;\\n        uint128 units;\\n    }\\n\\n    /// Errors ///\\n\\n    error POOL_MEMBER_NFT_NO_ZERO_POOL();\\n    error POOL_MEMBER_NFT_NO_ZERO_MEMBER();\\n    error POOL_MEMBER_NFT_NO_UNITS();\\n    error POOL_MEMBER_NFT_HAS_UNITS();\\n\\n    function onCreate(address pool, address member) external;\\n\\n    function onUpdate(address pool, address member) external;\\n\\n    function onDelete(address pool, address member) external;\\n\\n    /// View Functions ///\\n\\n    function poolMemberDataByTokenId(uint256 tokenId) external view returns (PoolMemberNFTData memory data);\\n}\",\"keccak256\":\"0x5a52452b00db96398759f1a2017ed8d76390730cb16a0d3e143b1fc7c5b99bed\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/gdav1/IPoolNFTBase.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >=0.8.4;\\n\\nimport { IERC721Metadata } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\ninterface IPoolNFTBase is IERC721Metadata {\\n    error POOL_NFT_APPROVE_TO_CALLER();                             // 0x9212b333\\n    error POOL_NFT_ONLY_SUPER_TOKEN_FACTORY();                      // 0x1fd7e3d8\\n    error POOL_NFT_INVALID_TOKEN_ID();                              // 0x09275994\\n    error POOL_NFT_APPROVE_TO_CURRENT_OWNER();                      // 0x020226d3\\n    error POOL_NFT_APPROVE_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();  // 0x1e82f255\\n    error POOL_NFT_NOT_REGISTERED_POOL();                           // 0x6421912e\\n    error POOL_NFT_TRANSFER_NOT_ALLOWED();                          // 0x432fb160\\n    error POOL_NFT_TRANSFER_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL(); // 0x4028ee0e\\n\\n    /// @notice Informs third-party platforms that NFT metadata should be updated\\n    /// @dev This event comes from https://eips.ethereum.org/EIPS/eip-4906\\n    /// @param tokenId the id of the token that should have its metadata updated\\n    event MetadataUpdate(uint256 tokenId);\\n\\n    function initialize(string memory nftName, string memory nftSymbol) external; // initializer;\\n\\n    function triggerMetadataUpdate(uint256 tokenId) external;\\n\\n    /// @notice Gets the token id\\n    /// @dev For PoolAdminNFT, `account` is admin and for PoolMemberNFT, `account` is member\\n    function getTokenId(address pool, address account) external view returns (uint256 tokenId);\\n}\\n\",\"keccak256\":\"0x1e5604256c5dd52f969b46feea0d708bde11c1a481bf7c50e33c67fd5dbf4262\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/gdav1/ISuperfluidPool.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >=0.8.4;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ISuperfluidToken } from \\\"../../superfluid/ISuperfluidToken.sol\\\";\\n\\n/**\\n * @dev The interface for any super token pool regardless of the distribution schemes.\\n */\\ninterface ISuperfluidPool is IERC20 {\\n    // Custom Errors\\n\\n    error SUPERFLUID_POOL_INVALID_TIME();               // 0x83c35016\\n    error SUPERFLUID_POOL_NO_POOL_MEMBERS();            // 0xe10f405a\\n    error SUPERFLUID_POOL_NO_ZERO_ADDRESS();            // 0x54eb6ee6\\n    error SUPERFLUID_POOL_NOT_POOL_ADMIN_OR_GDA();      // 0x1c5fbdcb\\n    error SUPERFLUID_POOL_NOT_GDA();                    // 0xfcbe3f9e\\n    error SUPERFLUID_POOL_TRANSFER_UNITS_NOT_ALLOWED(); // 0x2285efba\\n\\n    // Events\\n    event MemberUnitsUpdated(\\n        ISuperfluidToken indexed token, address indexed member, uint128 oldUnits, uint128 newUnits\\n    );\\n    event DistributionClaimed(\\n        ISuperfluidToken indexed token, address indexed member, int256 claimedAmount, int256 totalClaimed\\n    );\\n\\n    /// @notice A boolean indicating whether pool members can transfer their units\\n    function transferabilityForUnitsOwner() external view returns (bool);\\n\\n    /// @notice A boolean indicating whether addresses other than the pool admin can distribute via the pool\\n    function distributionFromAnyAddress() external view returns (bool);\\n\\n    /// @notice The pool admin\\n    /// @dev The admin is the creator of the pool and has permissions to update member units\\n    /// and is the recipient of the adjustment flow rate\\n    function admin() external view returns (address);\\n\\n    /// @notice The SuperToken for the pool\\n    function superToken() external view returns (ISuperfluidToken);\\n\\n    /// @notice The total units of the pool\\n    function getTotalUnits() external view returns (uint128);\\n\\n    /// @notice The total number of units of connected members\\n    function getTotalConnectedUnits() external view returns (uint128);\\n\\n    /// @notice The total number of units of disconnected members\\n    function getTotalDisconnectedUnits() external view returns (uint128);\\n\\n    /// @notice The total number of units for `memberAddr`\\n    /// @param memberAddr The address of the member\\n    function getUnits(address memberAddr) external view returns (uint128);\\n\\n    /// @notice The total flow rate of the pool\\n    function getTotalFlowRate() external view returns (int96);\\n\\n    /// @notice The flow rate of the connected members\\n    function getTotalConnectedFlowRate() external view returns (int96);\\n\\n    /// @notice The flow rate of the disconnected members\\n    function getTotalDisconnectedFlowRate() external view returns (int96);\\n\\n    /// @notice The balance of all the disconnected members at `time`\\n    /// @param time The time to query\\n    function getDisconnectedBalance(uint32 time) external view returns (int256 balance);\\n\\n    /// @notice The total amount received by `memberAddr` in the pool\\n    /// @param memberAddr The address of the member\\n    /// @return totalAmountReceived The total amount received by the member\\n    function getTotalAmountReceivedByMember(address memberAddr) external view returns (uint256 totalAmountReceived);\\n\\n    /// @notice The flow rate a member is receiving from the pool\\n    /// @param memberAddr The address of the member\\n    function getMemberFlowRate(address memberAddr) external view returns (int96);\\n\\n    /// @notice The claimable balance for `memberAddr` at `time` in the pool\\n    /// @param memberAddr The address of the member\\n    /// @param time The time to query\\n    function getClaimable(address memberAddr, uint32 time) external view returns (int256);\\n\\n    /// @notice The claimable balance for `memberAddr` at `block.timestamp` in the pool\\n    /// @param memberAddr The address of the member\\n    function getClaimableNow(address memberAddr) external view returns (int256 claimableBalance, uint256 timestamp);\\n\\n    /// @notice Sets `memberAddr` ownedUnits to `newUnits`\\n    /// @param memberAddr The address of the member\\n    /// @param newUnits The new units for the member\\n    function updateMemberUnits(address memberAddr, uint128 newUnits) external returns (bool);\\n\\n    /// @notice Claims the claimable balance for `memberAddr` at `block.timestamp`\\n    /// @param memberAddr The address of the member\\n    function claimAll(address memberAddr) external returns (bool);\\n\\n    /// @notice Claims the claimable balance for `msg.sender` at `block.timestamp`\\n    function claimAll() external returns (bool);\\n\\n    /// @notice Increases the allowance of `spender` by `addedValue`\\n    /// @param spender The address of the spender\\n    /// @param addedValue The amount to increase the allowance by\\n    /// @return true if successful\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /// @notice Decreases the allowance of `spender` by `subtractedValue`\\n    /// @param spender The address of the spender\\n    /// @param subtractedValue The amount to decrease the allowance by\\n    /// @return true if successful\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe56da2eab144290acce37576ad3f3b503a022e213f6302ce32a8d9da7c79f102\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\n/**\\n * @title Super app definitions library\\n * @author Superfluid\\n */\\nlibrary SuperAppDefinitions {\\n\\n    /**************************************************************************\\n    / App manifest config word\\n    /**************************************************************************/\\n\\n    /*\\n     * App level is a way to allow the app to whitelist what other app it can\\n     * interact with (aka. composite app feature).\\n     *\\n     * For more details, refer to the technical paper of superfluid protocol.\\n     */\\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\\n\\n    // The app is at the final level, hence it doesn't want to interact with any other app\\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\\n\\n    // The app is at the second level, it may interact with other final level apps if whitelisted\\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\\n\\n    function getAppCallbackLevel(uint256 configWord) internal pure returns (uint8) {\\n        return uint8(configWord & APP_LEVEL_MASK);\\n    }\\n\\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\\n    }\\n\\n    /**************************************************************************\\n    / Callback implementation bit masks\\n    /**************************************************************************/\\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\\n\\n    /**************************************************************************\\n    / App Jail Reasons\\n    /**************************************************************************/\\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\\n\\n    // Validate configWord cleaness for future compatibility, or else may introduce undefined future behavior\\n    function isConfigWordClean(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & ~(APP_LEVEL_MASK | APP_JAIL_BIT | AGREEMENT_CALLBACK_NOOP_BITMASKS)) == uint256(0);\\n    }\\n}\\n\\n/**\\n * @title Context definitions library\\n * @author Superfluid\\n */\\nlibrary ContextDefinitions {\\n\\n    /**************************************************************************\\n    / Call info\\n    /**************************************************************************/\\n\\n    // app level\\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\\n\\n    // call type\\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\\n\\n    function decodeCallInfo(uint256 callInfo)\\n        internal pure\\n        returns (uint8 appCallbackLevel, uint8 callType)\\n    {\\n        appCallbackLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n    function encodeCallInfo(uint8 appCallbackLevel, uint8 callType)\\n        internal pure\\n        returns (uint256 callInfo)\\n    {\\n        return uint256(appCallbackLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n}\\n\\n/**\\n * @title Flow Operator definitions library\\n  * @author Superfluid\\n */\\nlibrary FlowOperatorDefinitions {\\n   uint8 constant internal AUTHORIZE_FLOW_OPERATOR_CREATE = uint8(1) << 0;\\n   uint8 constant internal AUTHORIZE_FLOW_OPERATOR_UPDATE = uint8(1) << 1;\\n   uint8 constant internal AUTHORIZE_FLOW_OPERATOR_DELETE = uint8(1) << 2;\\n   uint8 constant internal AUTHORIZE_FULL_CONTROL =\\n       AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE;\\n   uint8 constant internal REVOKE_FLOW_OPERATOR_CREATE = ~(uint8(1) << 0);\\n   uint8 constant internal REVOKE_FLOW_OPERATOR_UPDATE = ~(uint8(1) << 1);\\n   uint8 constant internal REVOKE_FLOW_OPERATOR_DELETE = ~(uint8(1) << 2);\\n\\n   function isPermissionsClean(uint8 permissions) internal pure returns (bool) {\\n       return (\\n           permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE\\n               | AUTHORIZE_FLOW_OPERATOR_UPDATE\\n               | AUTHORIZE_FLOW_OPERATOR_DELETE)\\n           ) == uint8(0);\\n   }\\n}\\n\\n/**\\n * @title Batch operation library\\n * @author Superfluid\\n */\\nlibrary BatchOperation {\\n    /**\\n     * @dev ERC20.approve batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationApprove(\\n     *     abi.decode(data, (address spender, uint256 amount))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\\n    /**\\n     * @dev ERC20.transferFrom batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationTransferFrom(\\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\\n    /**\\n     * @dev ERC777.send batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationSend(\\n     *     abi.decode(data, (address recipient, uint256 amount, bytes userData)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC777_SEND = 3;\\n    /**\\n     * @dev ERC20.increaseAllowance batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationIncreaseAllowance(\\n     *     abi.decode(data, (address account, address spender, uint256 addedValue))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_INCREASE_ALLOWANCE = 4;\\n    /**\\n     * @dev ERC20.decreaseAllowance batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDecreaseAllowance(\\n     *     abi.decode(data, (address account, address spender, uint256 subtractedValue))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_DECREASE_ALLOWANCE = 5;\\n    /**\\n     * @dev SuperToken.upgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationUpgrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\\n    /**\\n     * @dev SuperToken.downgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDowngrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\\n    /**\\n     * @dev Superfluid.callAgreement batch operation type\\n     *\\n     * Call spec:\\n     * callAgreement(\\n     *     ISuperAgreement(target)),\\n     *     abi.decode(data, (bytes callData, bytes userData)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\\n    /**\\n     * @dev Superfluid.callAppAction batch operation type\\n     *\\n     * Call spec:\\n     * callAppAction(\\n     *     ISuperApp(target)),\\n     *     data\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\\n}\\n\\n/**\\n * @title Superfluid governance configs library\\n * @author Superfluid\\n */\\nlibrary SuperfluidGovernanceConfigs {\\n\\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.rewardAddress\\\");\\n    bytes32 constant internal CFAV1_PPP_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.PPPConfiguration\\\");\\n    bytes32 constant internal SUPERTOKEN_MINIMUM_DEPOSIT_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.superTokenMinimumDeposit\\\");\\n\\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.trustedForwarder\\\",\\n            forwarder));\\n    }\\n\\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\\\",\\n            deployer,\\n            registrationKey));\\n    }\\n\\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32)\\n    {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.factory\\\",\\n            factory));\\n    }\\n\\n    function decodePPPConfig(uint256 pppConfig) internal pure\\n        returns (uint256 liquidationPeriod, uint256 patricianPeriod)\\n    {\\n        liquidationPeriod = (pppConfig >> 32) & type(uint32).max;\\n        patricianPeriod = pppConfig & type(uint32).max;\\n    }\\n}\\n\",\"keccak256\":\"0x8e704e5f07cb1a4211a0b8462634735146f7cc29d2c4d4127a1e95767af2786f\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IConstantInflowNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\n\\ninterface IConstantInflowNFT is IFlowNFTBase {\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n    error CIF_NFT_ONLY_CONSTANT_OUTFLOW(); // 0xe81ef57a\\n\\n    /**************************************************************************\\n     * Write Functions\\n     *************************************************************************/\\n\\n    /// @notice The mint function emits the \\\"mint\\\" `Transfer` event.\\n    /// @dev We don't modify storage as this is handled in ConstantOutflowNFT.sol and this function's sole purpose\\n    /// is to inform clients that search for events.\\n    /// @param to the flow receiver (inflow NFT receiver)\\n    /// @param newTokenId the new token id\\n    function mint(address to, uint256 newTokenId) external;\\n\\n    /// @notice This burn function emits the \\\"burn\\\" `Transfer` event.\\n    /// @dev We don't modify storage as this is handled in ConstantOutflowNFT.sol and this function's sole purpose\\n    /// is to inform clients that search for events.\\n    /// @param tokenId desired token id to burn\\n    function burn(uint256 tokenId) external;\\n}\\n\",\"keccak256\":\"0xb219bf31e236fe6c2968ecf0f6c3eb24cb6774aaf4fcc83252e9b06bba718f33\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IConstantOutflowNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\n\\ninterface IConstantOutflowNFT is IFlowNFTBase {\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n\\n    error COF_NFT_INVALID_SUPER_TOKEN();            // 0x6de98774\\n    error COF_NFT_MINT_TO_AND_FLOW_RECEIVER_SAME(); // 0x0d1d1161\\n    error COF_NFT_MINT_TO_ZERO_ADDRESS();           // 0x43d05e51\\n    error COF_NFT_ONLY_CONSTANT_INFLOW();           // 0xa495a718\\n    error COF_NFT_ONLY_FLOW_AGREEMENTS();           // 0xd367b64f\\n    error COF_NFT_TOKEN_ALREADY_EXISTS();           // 0xe2480183\\n\\n\\n    /**************************************************************************\\n     * Write Functions\\n     *************************************************************************/\\n\\n    /// @notice The onCreate function is called when a new flow is created.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onCreate(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n\\n    /// @notice The onUpdate function is called when a flow is updated.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onUpdate(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n\\n    /// @notice The onDelete function is called when a flow is deleted.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onDelete(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n}\\n\",\"keccak256\":\"0x15799c1552fa7aad4c1a7197451cd02422a6c768b236ab2904e72f7158a4a2c2\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IFlowNFTBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport { IERC721Metadata } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\ninterface IFlowNFTBase is IERC721Metadata {\\n    // FlowNFTData struct storage packing:\\n    // b = bits\\n    // WORD 1: | superToken      | FREE\\n    //         | 160b            | 96b\\n    // WORD 2: | flowSender      | FREE\\n    //         | 160b            | 96b\\n    // WORD 3: | flowReceiver    | flowStartDate | FREE\\n    //         | 160b            | 32b           | 64b\\n    struct FlowNFTData {\\n        address superToken;\\n        address flowSender;\\n        address flowReceiver;\\n        uint32 flowStartDate;\\n    }\\n\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n\\n    error CFA_NFT_APPROVE_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();   // 0xa3352582\\n    error CFA_NFT_APPROVE_TO_CALLER();                              // 0xd3c77329\\n    error CFA_NFT_APPROVE_TO_CURRENT_OWNER();                       // 0xe4790b25\\n    error CFA_NFT_INVALID_TOKEN_ID();                               // 0xeab95e3b\\n    error CFA_NFT_ONLY_SUPER_TOKEN_FACTORY();                       // 0xebb7505b\\n    error CFA_NFT_TRANSFER_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();  // 0x2551d606\\n    error CFA_NFT_TRANSFER_FROM_INCORRECT_OWNER();                  // 0x5a26c744\\n    error CFA_NFT_TRANSFER_IS_NOT_ALLOWED();                        // 0xaa747eca\\n    error CFA_NFT_TRANSFER_TO_ZERO_ADDRESS();                       // 0xde06d21e\\n\\n    /**************************************************************************\\n     * Events\\n     *************************************************************************/\\n\\n    /// @notice Informs third-party platforms that NFT metadata should be updated\\n    /// @dev This event comes from https://eips.ethereum.org/EIPS/eip-4906\\n    /// @param tokenId the id of the token that should have its metadata updated\\n    event MetadataUpdate(uint256 tokenId);\\n\\n    /**************************************************************************\\n     * View\\n     *************************************************************************/\\n\\n    /// @notice An external function for querying flow data by `tokenId``\\n    /// @param tokenId the token id\\n    /// @return flowData the flow data associated with `tokenId`\\n    function flowDataByTokenId(\\n        uint256 tokenId\\n    ) external view returns (FlowNFTData memory flowData);\\n\\n    /// @notice An external function for computing the deterministic tokenId\\n    /// @dev tokenId = uint256(keccak256(abi.encode(block.chainId, superToken, flowSender, flowReceiver)))\\n    /// @param superToken the super token\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    /// @return tokenId the tokenId\\n    function getTokenId(\\n        address superToken,\\n        address flowSender,\\n        address flowReceiver\\n    ) external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Write\\n     *************************************************************************/\\n\\n    function initialize(\\n        string memory nftName,\\n        string memory nftSymbol\\n    ) external; // initializer;\\n\\n    function triggerMetadataUpdate(uint256 tokenId) external;\\n}\\n\",\"keccak256\":\"0xa1600ee907288d7852678cc43f995498a039710a4f025a8785de288c4a4ceced\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Super agreement interface\\n * @author Superfluid\\n */\\ninterface ISuperAgreement {\\n\\n    /**\\n     * @dev Get the type of the agreement class\\n     */\\n    function agreementType() external view returns (bytes32);\\n\\n    /**\\n     * @dev Calculate the real-time balance for the account of this agreement class\\n     * @param account Account the state belongs to\\n     * @param time Time used for the calculation\\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement\\n     * @return deposit Account deposit amount of this agreement\\n     * @return owedDeposit Account owed deposit amount of this agreement\\n     */\\n    function realtimeBalanceOf(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 time\\n    )\\n        external\\n        view\\n        returns (\\n            int256 dynamicBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n}\\n\",\"keccak256\":\"0xba0407c47917aee8b6e7cea745332d2f7244cc3b91d249426f0105b365feb0ee\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\n/**\\n * @title SuperApp interface\\n * @author Superfluid\\n * @dev Be aware of the app being jailed, when the word permitted is used.\\n */\\ninterface ISuperApp {\\n\\n    /**\\n     * @dev Callback before a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n     * @dev Callback after a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param cbdata The data returned from the before-hook callback.\\n     * @param ctx The context data.\\n     * @return newCtx The current context of the transaction.\\n     *\\n     * @custom:note \\n     * - State changes is permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Callback before a new agreement is updated.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n\\n    /**\\n    * @dev Callback after a new agreement is updated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Only revert with a \\\"reason\\\" is permitted.\\n    */\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n    * @dev Callback before a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param ctx The context data.\\n    * @return cbdata A free format in memory data the app can use to pass arbitary information to\\n    *         the after-hook callback.\\n    *\\n    * @custom:note \\n    * - It will be invoked with `staticcall`, no state changes are permitted.\\n    * - Revert is not permitted.\\n    */\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n    * @dev Callback after a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Revert is not permitted.\\n    */\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n}\\n\",\"keccak256\":\"0x9a1cbf6d6037aac2381e8e66a2ad89e9afe6f89b290c21cb587ff6b06d137ee2\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { IERC20, IERC20Metadata } from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { IConstantOutflowNFT } from \\\"./IConstantOutflowNFT.sol\\\";\\nimport { IConstantInflowNFT } from \\\"./IConstantInflowNFT.sol\\\";\\nimport { IPoolAdminNFT } from \\\"../agreements/gdav1/IPoolAdminNFT.sol\\\";\\nimport { IPoolMemberNFT } from \\\"../agreements/gdav1/IPoolMemberNFT.sol\\\";\\n\\n/**\\n * @title Super token (Superfluid Token + ERC20 + ERC777) interface\\n * @author Superfluid\\n */\\ninterface ISuperToken is ISuperfluidToken, IERC20Metadata, IERC777 {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SUPER_TOKEN_CALLER_IS_NOT_OPERATOR_FOR_HOLDER();       // 0xf7f02227\\n    error SUPER_TOKEN_NOT_ERC777_TOKENS_RECIPIENT();             // 0xfe737d05\\n    error SUPER_TOKEN_INFLATIONARY_DEFLATIONARY_NOT_SUPPORTED(); // 0xe3e13698\\n    error SUPER_TOKEN_NO_UNDERLYING_TOKEN();                     // 0xf79cf656\\n    error SUPER_TOKEN_ONLY_SELF();                               // 0x7ffa6648\\n    error SUPER_TOKEN_ONLY_ADMIN();                              // 0x0484acab\\n    error SUPER_TOKEN_ONLY_GOV_OWNER();                          // 0xd9c7ed08\\n    error SUPER_TOKEN_APPROVE_FROM_ZERO_ADDRESS();               // 0x81638627\\n    error SUPER_TOKEN_APPROVE_TO_ZERO_ADDRESS();                 // 0xdf070274\\n    error SUPER_TOKEN_BURN_FROM_ZERO_ADDRESS();                  // 0xba2ab184\\n    error SUPER_TOKEN_MINT_TO_ZERO_ADDRESS();                    // 0x0d243157\\n    error SUPER_TOKEN_TRANSFER_FROM_ZERO_ADDRESS();              // 0xeecd6c9b\\n    error SUPER_TOKEN_TRANSFER_TO_ZERO_ADDRESS();                // 0xe219bd39\\n    error SUPER_TOKEN_NFT_PROXY_ADDRESS_CHANGED();               // 0x6bef249d\\n\\n    /**\\n     * @dev Initialize the contract\\n     */\\n    function initialize(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s\\n    ) external;\\n\\n    /**\\n     * @dev Initialize the contract with an admin\\n     */\\n    function initializeWithAdmin(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s,\\n        address admin\\n    ) external;\\n\\n    /**\\n     * @notice Changes the admin for the SuperToken\\n     * @dev Only the current admin can call this function\\n     * if admin is address(0), it is implicitly the host address\\n     * @param newAdmin New admin address\\n     */\\n    function changeAdmin(address newAdmin) external;\\n\\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\\n\\n    /**\\n     * @dev Returns the admin address for the SuperToken\\n     */\\n    function getAdmin() external view returns (address admin);\\n\\n    /**************************************************************************\\n    * Immutable variables\\n    *************************************************************************/\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CONSTANT_OUTFLOW_NFT() external view returns (IConstantOutflowNFT);\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CONSTANT_INFLOW_NFT() external view returns (IConstantInflowNFT);\\n    // solhint-disable-next-line func-name-mixedcase\\n    function POOL_ADMIN_NFT() external view returns (IPoolAdminNFT);\\n    // solhint-disable-next-line func-name-mixedcase\\n    function POOL_MEMBER_NFT() external view returns (IPoolMemberNFT);\\n\\n    /**************************************************************************\\n    * IERC20Metadata & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view override(IERC777, IERC20Metadata) returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override(IERC777, IERC20Metadata) returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * @custom:note SuperToken always uses 18 decimals.\\n     *\\n     * This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override(IERC20Metadata) returns (uint8);\\n\\n    /**************************************************************************\\n    * ERC20 & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\\n\\n    /**************************************************************************\\n    * ERC20\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     *         allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     *         zero by default.\\n     *\\n     * @notice This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:note Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * @custom:emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     *         allowance mechanism. `amount` is then deducted from the caller's\\n     *         allowance.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**************************************************************************\\n    * ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     *         means all token operations (creation, movement and destruction) must have\\n     *         amounts that are a multiple of this number.\\n     *\\n     * @custom:note For super token contracts, this value is always 1\\n     */\\n    function granularity() external view override(IERC777) returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @dev If send or receive hooks are registered for the caller and `recipient`,\\n     *      the corresponding functions will be called with `userData` and empty\\n     *      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata userData) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply and transfers the underlying token to the caller's account.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `userData` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata userData) external override(IERC777);\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * @custom:emits an {AuthorizedOperator} event.\\n     *\\n     * @custom:requirements\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * @custom:emits a {RevokedOperator} event.\\n     *\\n     * @custom:requirements\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `userData` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `userData` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**************************************************************************\\n     * SuperToken custom token functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Mint new tokens for the account\\n     * If `userData` is not empty, the `tokensReceived` hook is invoked according to ERC777 semantics.\\n     *\\n     * @custom:modifiers\\n     *  - onlySelf\\n     */\\n    function selfMint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n   /**\\n    * @dev Burn existing tokens for the account\\n    * If `userData` is not empty, the `tokensToSend` hook is invoked according to ERC777 semantics.\\n    *\\n    * @custom:modifiers\\n    *  - onlySelf\\n    */\\n   function selfBurn(\\n       address account,\\n       uint256 amount,\\n       bytes memory userData\\n   ) external;\\n\\n   /**\\n    * @dev Transfer `amount` tokens from the `sender` to `recipient`.\\n    * If `spender` isn't the same as `sender`, checks if `spender` has allowance to\\n    * spend tokens of `sender`.\\n    *\\n    * @custom:modifiers\\n    *  - onlySelf\\n    */\\n   function selfTransferFrom(\\n        address sender,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n   ) external;\\n\\n   /**\\n    * @dev Give `spender`, `amount` allowance to spend the tokens of\\n    * `account`.\\n    *\\n    * @custom:modifiers\\n    *  - onlySelf\\n    */\\n   function selfApproveFor(\\n        address account,\\n        address spender,\\n        uint256 amount\\n   ) external;\\n\\n    /**************************************************************************\\n     * SuperToken extra functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\\n     */\\n    function transferAll(address recipient) external;\\n\\n    /**************************************************************************\\n     * ERC20 wrapping\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Return the underlying token contract\\n     * @return tokenAddr Underlying token address\\n     */\\n    function getUnderlyingToken() external view returns(address tokenAddr);\\n\\n    /**\\n     * @dev Return the underlying token decimals\\n     * @return underlyingDecimals Underlying token decimals\\n     */\\n    function getUnderlyingDecimals() external view returns (uint8 underlyingDecimals);\\n\\n    /**\\n     * @dev Return the underlying token conversion rate\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @return underlyingAmount The underlying token amount after scaling\\n     * @return adjustedAmount The super token amount after scaling\\n     */\\n    function toUnderlyingAmount(uint256 amount)\\n        external\\n        view\\n        returns (uint256 underlyingAmount, uint256 adjustedAmount);\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken.\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     */\\n    function upgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\\n     * @param to The account to receive upgraded tokens\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @param userData User data for the TokensRecipient callback\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     *\\n     * @custom:warning\\n     * - there is potential of reentrancy IF the \\\"to\\\" account is a registered ERC777 recipient.\\n     * @custom:requirements\\n     * - if `userData` is NOT empty AND `to` is a contract, it MUST be a registered ERC777 recipient\\n     *   otherwise it reverts.\\n     */\\n    function upgradeTo(address to, uint256 amount, bytes calldata userData) external;\\n\\n    /**\\n     * @dev Token upgrade event\\n     * @param account Account where tokens are upgraded to\\n     * @param amount Amount of tokens upgraded (in 18 decimals)\\n     */\\n    event TokenUpgraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20.\\n     * @dev It will call transfer to send tokens\\n     * @param amount Number of tokens to be downgraded\\n     */\\n    function downgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20 and transfer immediately\\n     * @param to The account to receive downgraded tokens\\n     * @param amount Number of tokens to be downgraded (in 18 decimals)\\n     */\\n    function downgradeTo(address to, uint256 amount) external;\\n\\n    /**\\n     * @dev Token downgrade event\\n     * @param account Account whose tokens are downgraded\\n     * @param amount Amount of tokens downgraded\\n     */\\n    event TokenDowngraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**************************************************************************\\n    * Batch Operations\\n    *************************************************************************/\\n\\n    /**\\n    * @dev Perform ERC20 approve by host contract.\\n    * @param account The account owner to be approved.\\n    * @param spender The spender of account owner's funds.\\n    * @param amount Number of tokens to be approved.\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationApprove(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    function operationIncreaseAllowance(\\n        address account,\\n        address spender,\\n        uint256 addedValue\\n    ) external;\\n\\n    function operationDecreaseAllowance(\\n        address account,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC20 transferFrom by host contract.\\n    * @param account The account to spend sender's funds.\\n    * @param spender The account where the funds is sent from.\\n    * @param recipient The recipient of the funds.\\n    * @param amount Number of tokens to be transferred.\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationTransferFrom(\\n        address account,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC777 send by host contract.\\n    * @param spender The account where the funds is sent from.\\n    * @param recipient The recipient of the funds.\\n    * @param amount Number of tokens to be transferred.\\n    * @param userData Arbitrary user inputted data\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationSend(\\n        address spender,\\n        address recipient,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n    /**\\n    * @dev Upgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationUpgrade(address account, uint256 amount) external;\\n\\n    /**\\n    * @dev Downgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers\\n    *  - onlyHost\\n    */\\n    function operationDowngrade(address account, uint256 amount) external;\\n\\n    // Flow NFT events\\n    /**\\n     * @dev Constant Outflow NFT proxy created event\\n     * @param constantOutflowNFT constant outflow nft address\\n     */\\n    event ConstantOutflowNFTCreated(\\n        IConstantOutflowNFT indexed constantOutflowNFT\\n    );\\n\\n    /**\\n     * @dev Constant Inflow NFT proxy created event\\n     * @param constantInflowNFT constant inflow nft address\\n     */\\n    event ConstantInflowNFTCreated(\\n        IConstantInflowNFT indexed constantInflowNFT\\n    );\\n\\n    /**\\n     * @dev Pool Admin NFT proxy created event\\n     * @param poolAdminNFT pool admin nft address\\n     */\\n    event PoolAdminNFTCreated(\\n        IPoolAdminNFT indexed poolAdminNFT\\n    );\\n\\n    /**\\n     * @dev Pool Member NFT proxy created event\\n     * @param poolMemberNFT pool member nft address\\n     */\\n    event PoolMemberNFTCreated(\\n        IPoolMemberNFT indexed poolMemberNFT\\n    );\\n\\n    /**************************************************************************\\n    * Function modifiers for access control and parameter validations\\n    *\\n    * While they cannot be explicitly stated in function definitions, they are\\n    * listed in function definition comments instead for clarity.\\n    *\\n    * NOTE: solidity-coverage not supporting it\\n    *************************************************************************/\\n\\n    /// @dev The msg.sender must be the contract itself\\n    //modifier onlySelf() virtual\\n\\n}\\n\",\"keccak256\":\"0xb37442187735f9a8d6e18d736a5418b1ef6cf8c811fa694d6605ba27a0b9268e\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { IERC20Metadata } from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n/**\\n * @title Super token factory interface\\n * @author Superfluid\\n */\\ninterface ISuperTokenFactory {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SUPER_TOKEN_FACTORY_ALREADY_EXISTS();                 // 0x91d67972\\n    error SUPER_TOKEN_FACTORY_DOES_NOT_EXIST();                 // 0x872cac48\\n    error SUPER_TOKEN_FACTORY_UNINITIALIZED();                  // 0x1b39b9b4\\n    error SUPER_TOKEN_FACTORY_ONLY_HOST();                      // 0x478b8e83\\n    error SUPER_TOKEN_FACTORY_NON_UPGRADEABLE_IS_DEPRECATED();  // 0xc4901a43\\n    error SUPER_TOKEN_FACTORY_ZERO_ADDRESS();                   // 0x305c9e82\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /// @dev Initialize the contract\\n    function initialize() external;\\n\\n    /**\\n     * @notice Get the canonical super token logic.\\n     */\\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Upgradability modes\\n     */\\n    enum Upgradability {\\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\\n        NON_UPGRADABLE,\\n        /// Upgradable through `host.updateSuperTokenLogic` operation\\n        SEMI_UPGRADABLE,\\n        /// Always using the latest super token logic\\n        FULL_UPGRADABLE\\n    }\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @param admin Admin address\\n     * @return superToken The deployed and initialized wrapper super token\\n     */\\n    function createERC20Wrapper(\\n        IERC20Metadata underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol,\\n        address admin\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @return superToken The deployed and initialized wrapper super token\\n     */\\n    function createERC20Wrapper(\\n        IERC20Metadata underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @param admin Admin address\\n     * @return superToken The deployed and initialized wrapper super token\\n     */\\n    function createERC20Wrapper(\\n        IERC20Metadata underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol,\\n        address admin\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token with extra token info\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @return superToken The deployed and initialized wrapper super token\\n     * NOTE:\\n     * - It assumes token provide the .decimals() function\\n     */\\n    function createERC20Wrapper(\\n        IERC20Metadata underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Creates a wrapper super token AND sets it in the canonical list OR reverts if it already exists\\n     * @dev salt for create2 is the keccak256 hash of abi.encode(address(_underlyingToken))\\n     * @param _underlyingToken Underlying ERC20 token\\n     * @return ISuperToken the created supertoken\\n     */\\n    function createCanonicalERC20Wrapper(IERC20Metadata _underlyingToken)\\n        external\\n        returns (ISuperToken);\\n\\n    /**\\n     * @notice Computes/Retrieves wrapper super token address given the underlying token address\\n     * @dev We return from our canonical list if it already exists, otherwise we compute it\\n     * @dev note that this function only computes addresses for SEMI_UPGRADABLE SuperTokens\\n     * @param _underlyingToken Underlying ERC20 token address\\n     * @return superTokenAddress Super token address\\n     * @return isDeployed whether the super token is deployed AND set in the canonical mapping\\n     */\\n    function computeCanonicalERC20WrapperAddress(address _underlyingToken)\\n        external\\n        view\\n        returns (address superTokenAddress, bool isDeployed);\\n\\n    /**\\n     * @notice Gets the canonical ERC20 wrapper super token address given the underlying token address\\n     * @dev We return the address if it exists and the zero address otherwise\\n     * @param _underlyingTokenAddress Underlying ERC20 token address\\n     * @return superTokenAddress Super token address\\n     */\\n    function getCanonicalERC20Wrapper(address _underlyingTokenAddress)\\n        external\\n        view\\n        returns (address superTokenAddress);\\n\\n    /**\\n     * @dev Creates a new custom super token\\n     * @param customSuperTokenProxy address of the custom supertoken proxy\\n     */\\n    function initializeCustomSuperToken(\\n        address customSuperTokenProxy\\n    )\\n        external;\\n\\n    /**\\n      * @dev Super token logic created event\\n      * @param tokenLogic Token logic address\\n      */\\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\\n\\n    /**\\n      * @dev Super token created event\\n      * @param token Newly created super token address\\n      */\\n    event SuperTokenCreated(ISuperToken indexed token);\\n\\n    /**\\n      * @dev Custom super token created event\\n      * @param token Newly created custom super token address\\n      */\\n    event CustomSuperTokenCreated(ISuperToken indexed token);\\n\\n}\",\"keccak256\":\"0x85b2cae18114b9253080a6f237eb10b5bd47b696ea4ac6f2c6fde17ab09758e3\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\n// ISuperfluid.sol can also be used as an umbrella-import for everything Superfluid, hence we should have these unused\\n// import.\\n//\\n// solhint-disable no-unused-import\\n\\n/// Global definitions\\nimport {\\n    SuperAppDefinitions,\\n    ContextDefinitions,\\n    FlowOperatorDefinitions,\\n    BatchOperation,\\n    SuperfluidGovernanceConfigs\\n} from \\\"./Definitions.sol\\\";\\n/// Super token related interfaces:\\n/// Note: CustomSuperTokenBase is not included for people building CustomSuperToken.\\nimport { IERC20, IERC20Metadata } from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperTokenFactory } from \\\"./ISuperTokenFactory.sol\\\";\\nimport { ISETH } from \\\"../tokens/ISETH.sol\\\";\\n/// Superfluid/ERC20x NFTs\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\nimport { IConstantOutflowNFT } from \\\"./IConstantOutflowNFT.sol\\\";\\nimport { IConstantInflowNFT } from \\\"./IConstantInflowNFT.sol\\\";\\nimport { IPoolAdminNFT } from \\\"../agreements/gdav1/IPoolAdminNFT.sol\\\";\\nimport { IPoolMemberNFT } from \\\"../agreements/gdav1/IPoolMemberNFT.sol\\\";\\n/// Superfluid agreement interfaces:\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { IConstantFlowAgreementV1 } from \\\"../agreements/IConstantFlowAgreementV1.sol\\\";\\nimport { IInstantDistributionAgreementV1 } from \\\"../agreements/IInstantDistributionAgreementV1.sol\\\";\\nimport { IGeneralDistributionAgreementV1, PoolConfig } from \\\"../agreements/gdav1/IGeneralDistributionAgreementV1.sol\\\";\\nimport { ISuperfluidPool } from \\\"../agreements/gdav1/ISuperfluidPool.sol\\\";\\n/// Superfluid App interfaces:\\nimport { ISuperApp } from \\\"./ISuperApp.sol\\\";\\n/// Superfluid governance\\nimport { ISuperfluidGovernance } from \\\"./ISuperfluidGovernance.sol\\\";\\n\\n/**\\n * @title Host interface\\n * @author Superfluid\\n * @notice This is the central contract of the system where super agreement, super app\\n * and super token features are connected.\\n *\\n * The Superfluid host contract is also the entry point for the protocol users,\\n * where batch call and meta transaction are provided for UX improvements.\\n *\\n */\\ninterface ISuperfluid {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    // Superfluid Custom Errors\\n    error HOST_AGREEMENT_CALLBACK_IS_NOT_ACTION();              // 0xef4295f6\\n    error HOST_CANNOT_DOWNGRADE_TO_NON_UPGRADEABLE();           // 0x474e7641\\n    error HOST_CALL_AGREEMENT_WITH_CTX_FROM_WRONG_ADDRESS();    // 0x0cd0ebc2\\n    error HOST_CALL_APP_ACTION_WITH_CTX_FROM_WRONG_ADDRESS();   // 0x473f7bd4\\n    error HOST_INVALID_CONFIG_WORD();                           // 0xf4c802a4\\n    error HOST_MAX_256_AGREEMENTS();                            // 0x7c281a78\\n    error HOST_NON_UPGRADEABLE();                               // 0x14f72c9f\\n    error HOST_NON_ZERO_LENGTH_PLACEHOLDER_CTX();               // 0x67e9985b\\n    error HOST_ONLY_GOVERNANCE();                               // 0xc5d22a4e\\n    error HOST_UNKNOWN_BATCH_CALL_OPERATION_TYPE();             // 0xb4770115\\n    error HOST_AGREEMENT_ALREADY_REGISTERED();                  // 0xdc9ddba8\\n    error HOST_AGREEMENT_IS_NOT_REGISTERED();                   // 0x1c9e9bea\\n    error HOST_MUST_BE_CONTRACT();                              // 0xd4f6b30c\\n    error HOST_ONLY_LISTED_AGREEMENT();                         // 0x619c5359\\n    error HOST_NEED_MORE_GAS();                                 // 0xd4f5d496\\n\\n    // App Related Custom Errors\\n    // uses SuperAppDefinitions' App Jail Reasons as _code\\n    error APP_RULE(uint256 _code);                              // 0xa85ba64f\\n\\n    error HOST_NOT_A_SUPER_APP();                               // 0x163cbe43\\n    error HOST_NO_APP_REGISTRATION_PERMISSION();                // 0xb56455f0\\n    error HOST_RECEIVER_IS_NOT_SUPER_APP();                     // 0x96aa315e\\n    error HOST_SENDER_IS_NOT_SUPER_APP();                       // 0xbacfdc40\\n    error HOST_SOURCE_APP_NEEDS_HIGHER_APP_LEVEL();             // 0x44725270\\n    error HOST_SUPER_APP_IS_JAILED();                           // 0x02384b64\\n    error HOST_SUPER_APP_ALREADY_REGISTERED();                  // 0x01b0a935\\n\\n    /**************************************************************************\\n     * Time\\n     *\\n     * > The Oracle: You have the sight now, Neo. You are looking at the world without time.\\n     * > Neo: Then why can't I see what happens to her?\\n     * > The Oracle: We can never see past the choices we don't understand.\\n     * >       - The Oracle and Neo conversing about the future of Trinity and the effects of Neo's choices\\n     *************************************************************************/\\n\\n    function getNow() external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Governance\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get the current governance address of the Superfluid host\\n     */\\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\\n\\n    /**\\n     * @dev Replace the current governance with a new one\\n     */\\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\\n    /**\\n     * @dev Governance replaced event\\n     * @param oldGov Address of the old governance contract\\n     * @param newGov Address of the new governance contract\\n     */\\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\\n\\n    /**************************************************************************\\n     * Agreement Whitelisting\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Register a new agreement class to the system\\n     * @param agreementClassLogic Initial agreement class code\\n     *\\n     * @custom:modifiers\\n     * - onlyGovernance\\n     */\\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class registered event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type registered\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassRegistered(bytes32 agreementType, address code);\\n\\n    /**\\n    * @dev Update code of an agreement class\\n    * @param agreementClassLogic New code for the agreement class\\n    *\\n    * @custom:modifiers\\n    *  - onlyGovernance\\n    */\\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class updated event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type updated\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassUpdated(bytes32 agreementType, address code);\\n\\n    /**\\n    * @notice Check if the agreement type is whitelisted\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\\n\\n    /**\\n    * @notice Get agreement class\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\\n\\n    /**\\n    * @dev Map list of the agreement classes using a bitmap\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function mapAgreementClasses(uint256 bitmap)\\n        external view\\n        returns (ISuperAgreement[] memory agreementClasses);\\n\\n    /**\\n    * @notice Create a new bitmask by adding a agreement class to it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**\\n    * @notice Create a new bitmask by removing a agreement class from it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**************************************************************************\\n    * Super Token Factory\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get the super token factory\\n     * @return factory The factory\\n     */\\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\\n\\n    /**\\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\\n     * @return logic The factory logic\\n     */\\n    function getSuperTokenFactoryLogic() external view returns (address logic);\\n\\n    /**\\n     * @dev Update super token factory\\n     * @param newFactory New factory logic\\n     */\\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\\n    /**\\n     * @dev SuperToken factory updated event\\n     * @param newFactory Address of the new factory\\n     */\\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\\n\\n    /**\\n     * @notice Update the super token logic to the latest (canonical) implementation\\n     * if `newLogicOverride` is zero, or to `newLogicOverride` otherwise.\\n     * or to the provided implementation `.\\n     * @dev Refer to ISuperTokenFactory.Upgradability for expected behaviours\\n     */\\n    function updateSuperTokenLogic(ISuperToken token, address newLogicOverride) external;\\n    /**\\n     * @notice Update the super token logic to the provided one\\n     * @dev newLogic must implement UUPSProxiable with matching proxiableUUID\\n     */\\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\\n\\n    /**\\n     * @notice Change the SuperToken admin address\\n     * @dev The admin is the only account allowed to update the token logic\\n     * For backward compatibility, the \\\"host\\\" is the default \\\"admin\\\" if unset (address(0)).\\n     */\\n    function changeSuperTokenAdmin(ISuperToken token, address newAdmin) external;\\n\\n    /**\\n     * @notice Change the implementation address the pool beacon points to\\n     * @dev Updating the logic the beacon points to will update the logic of all the Pool BeaconProxy instances\\n     */\\n    function updatePoolBeaconLogic(address newBeaconLogic) external;\\n\\n    /**\\n     * @dev Pool Beacon logic updated event\\n     * @param beaconProxy addrss of the beacon proxy\\n     * @param newBeaconLogic address of the new beacon logic\\n     */\\n    event PoolBeaconLogicUpdated(address indexed beaconProxy, address newBeaconLogic);\\n\\n    /**************************************************************************\\n     * App Registry\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Message sender (must be a contract) registers itself as a super app.\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     * @notice On some mainnet deployments, pre-authorization by governance may be needed for this to succeed.\\n     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     */\\n    function registerApp(uint256 configWord) external;\\n\\n    /**\\n     * @dev Registers an app (must be a contract) as a super app.\\n     * @param app The super app address\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     * @notice On some mainnet deployments, pre-authorization by governance may be needed for this to succeed.\\n     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     */\\n    function registerApp(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev App registered event\\n     * @param app Address of jailed app\\n     */\\n    event AppRegistered(ISuperApp indexed app);\\n\\n    /**\\n     * @dev DO NOT USE for new deployments\\n     * @custom:deprecated you should use `registerApp(uint256 configWord) instead.\\n     */\\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\\n\\n    /**\\n     * @dev DO NOT USE for new deployments\\n     * @custom:deprecated you should use `registerApp(ISuperApp app, uint256 configWord) instead.\\n     */\\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev Query if the app is registered\\n     * @param app Super app address\\n     */\\n    function isApp(ISuperApp app) external view returns(bool);\\n\\n    /**\\n     * @dev Query app callbacklevel\\n     * @param app Super app address\\n     */\\n    function getAppCallbackLevel(ISuperApp app) external view returns(uint8 appCallbackLevel);\\n\\n    /**\\n     * @dev Get the manifest of the super app\\n     * @param app Super app address\\n     */\\n    function getAppManifest(\\n        ISuperApp app\\n    )\\n        external view\\n        returns (\\n            bool isSuperApp,\\n            bool isJailed,\\n            uint256 noopMask\\n        );\\n\\n    /**\\n     * @dev Query if the app has been jailed\\n     * @param app Super app address\\n     */\\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\\n\\n    /**\\n     * @dev Whitelist the target app for app composition for the source app (msg.sender)\\n     * @param targetApp The target super app address\\n     */\\n    function allowCompositeApp(ISuperApp targetApp) external;\\n\\n    /**\\n     * @dev Query if source app is allowed to call the target app as downstream app\\n     * @param app Super app address\\n     * @param targetApp The target super app address\\n     */\\n    function isCompositeAppAllowed(\\n        ISuperApp app,\\n        ISuperApp targetApp\\n    )\\n        external view\\n        returns (bool isAppAllowed);\\n\\n    /**************************************************************************\\n     * Agreement Framework\\n     *\\n     * Agreements use these function to trigger super app callbacks, updates\\n     * app credit and charge gas fees.\\n     *\\n     * These functions can only be called by registered agreements.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev (For agreements) StaticCall the app before callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return cbdata            Data returned from the callback.\\n     */\\n    function callAppBeforeCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory cbdata);\\n\\n    /**\\n     * @dev (For agreements) Call the app after callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return newCtx            The current context of the transaction.\\n     */\\n    function callAppAfterCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Create a new callback stack\\n     * @param  ctx                     The current ctx, it will be validated.\\n     * @param  app                     The super app.\\n     * @param  appCreditGranted        App credit granted so far.\\n     * @param  appCreditUsed           App credit used so far.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function appCallbackPush(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 appCreditGranted,\\n        int256 appCreditUsed,\\n        ISuperfluidToken appCreditToken\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Pop from the current app callback stack\\n     * @param  ctx                     The ctx that was pushed before the callback stack.\\n     * @param  appCreditUsedDelta      App credit used by the app.\\n     * @return newCtx                  The current context of the transaction.\\n     *\\n     * @custom:security\\n     * - Here we cannot do assertValidCtx(ctx), since we do not really save the stack in memory.\\n     * - Hence there is still implicit trust that the agreement handles the callback push/pop pair correctly.\\n     */\\n    function appCallbackPop(\\n        bytes calldata ctx,\\n        int256 appCreditUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Use app credit.\\n     * @param  ctx                      The current ctx, it will be validated.\\n     * @param  appCreditUsedMore        See app credit for more details.\\n     * @return newCtx                   The current context of the transaction.\\n     */\\n    function ctxUseCredit(\\n        bytes calldata ctx,\\n        int256 appCreditUsedMore\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Jail the app.\\n     * @param  app                     The super app.\\n     * @param  reason                  Jail reason code.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function jailApp(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 reason\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Jail event for the app\\n     * @param app Address of jailed app\\n     * @param reason Reason the app is jailed (see Definitions.sol for the full list)\\n     */\\n    event Jail(ISuperApp indexed app, uint256 reason);\\n\\n    /**************************************************************************\\n     * Contextless Call Proxies\\n     *\\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\\n     * with agreements or apps.\\n     *\\n     * NOTE: The contextual call data should be generated using\\n     * abi.encodeWithSelector. The context parameter should be set to \\\"0x\\\",\\n     * an empty bytes array as a placeholder to be replaced by the host\\n     * contract.\\n     *************************************************************************/\\n\\n     /**\\n      * @dev Call agreement function\\n      * @param agreementClass The agreement address you are calling\\n      * @param callData The contextual call data with placeholder ctx\\n      * @param userData Extra user data being sent to the super app callbacks\\n      */\\n     function callAgreement(\\n         ISuperAgreement agreementClass,\\n         bytes calldata callData,\\n         bytes calldata userData\\n     )\\n        external\\n        //cleanCtx\\n        //isAgreement(agreementClass)\\n        returns(bytes memory returnedData);\\n\\n    /**\\n     * @notice Call app action\\n     * @dev Main use case is calling app action in a batch call via the host\\n     * @param callData The contextual call data\\n     *\\n     * @custom:note See \\\"Contextless Call Proxies\\\" above for more about contextual call data.\\n     */\\n    function callAppAction(\\n        ISuperApp app,\\n        bytes calldata callData\\n    )\\n        external\\n        //cleanCtx\\n        //isAppActive(app)\\n        //isValidAppAction(callData)\\n        returns(bytes memory returnedData);\\n\\n    /**************************************************************************\\n     * Contextual Call Proxies and Context Utilities\\n     *\\n     * For apps, they must use context they receive to interact with\\n     * agreements or apps.\\n     *\\n     * The context changes must be saved and returned by the apps in their\\n     * callbacks always, any modification to the context will be detected and\\n     * the violating app will be jailed.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Context Struct\\n     *\\n     * @custom:note on backward compatibility:\\n     * - Non-dynamic fields are padded to 32bytes and packed\\n     * - Dynamic fields are referenced through a 32bytes offset to their \\\"parents\\\" field (or root)\\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\\n     *    - non-dynamic fields will be parsed at the same memory location,\\n     *    - and dynamic fields will simply have a greater offset than it was.\\n     * - We cannot change the structure of the Context struct because of ABI compatibility requirements\\n     */\\n    struct Context {\\n        //\\n        // Call context\\n        //\\n        // app callback level\\n        uint8 appCallbackLevel;\\n        // type of call\\n        uint8 callType;\\n        // the system timestamp\\n        uint256 timestamp;\\n        // The intended message sender for the call\\n        address msgSender;\\n\\n        //\\n        // Callback context\\n        //\\n        // For callbacks it is used to know which agreement function selector is called\\n        bytes4 agreementSelector;\\n        // User provided data for app callbacks\\n        bytes userData;\\n\\n        //\\n        // App context\\n        //\\n        // app credit granted\\n        uint256 appCreditGranted;\\n        // app credit wanted by the app callback\\n        uint256 appCreditWantedDeprecated;\\n        // app credit used, allowing negative values over a callback session\\n        // the appCreditUsed value over a callback sessions is calculated with:\\n        // existing flow data owed deposit + sum of the callback agreements\\n        // deposit deltas\\n        // the final value used to modify the state is determined by the\\n        // _adjustNewAppCreditUsed function (in AgreementLibrary.sol) which takes\\n        // the appCreditUsed value reached in the callback session and the app\\n        // credit granted\\n        int256 appCreditUsed;\\n        // app address\\n        address appAddress;\\n        // app credit in super token\\n        ISuperfluidToken appCreditToken;\\n    }\\n\\n    function callAgreementWithContext(\\n        ISuperAgreement agreementClass,\\n        bytes calldata callData,\\n        bytes calldata userData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // onlyAgreement(agreementClass)\\n        returns (bytes memory newCtx, bytes memory returnedData);\\n\\n    function callAppActionWithContext(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // isAppActive(app)\\n        returns (bytes memory newCtx);\\n\\n    function decodeCtx(bytes memory ctx)\\n        external pure\\n        returns (Context memory context);\\n\\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\\n\\n    /**************************************************************************\\n    * Batch call\\n    **************************************************************************/\\n    /**\\n     * @dev Batch operation data\\n     */\\n    struct Operation {\\n        // Operation type. Defined in BatchOperation (Definitions.sol)\\n        uint32 operationType;\\n        // Operation target\\n        address target;\\n        // Data specific to the operation\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Batch call function\\n     * @param operations Array of batch operations\\n     */\\n    function batchCall(Operation[] calldata operations) external payable;\\n\\n    /**\\n     * @dev Batch call function for trusted forwarders (EIP-2771)\\n     * @param operations Array of batch operations\\n     */\\n    function forwardBatchCall(Operation[] calldata operations) external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * TODO: turning these off because solidity-coverage doesn't like it\\n     *************************************************************************/\\n\\n     /* /// @dev The current superfluid context is clean.\\n     modifier cleanCtx() virtual;\\n\\n     /// @dev Require the ctx being valid.\\n     modifier requireValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev Assert the ctx being valid.\\n     modifier assertValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev The agreement is a listed agreement.\\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\\n\\n     // onlyGovernance\\n\\n     /// @dev The msg.sender must be a listed agreement.\\n     modifier onlyAgreement() virtual;\\n\\n     /// @dev The app is registered and not jailed.\\n     modifier isAppActive(ISuperApp app) virtual; */\\n}\\n\",\"keccak256\":\"0x238580132a10a263caf237c37477200100650330884ec58f2641e4fd2bb9b38e\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Superfluid governance interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidGovernance {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SF_GOV_INVALID_LIQUIDATION_OR_PATRICIAN_PERIOD(); // 0xe171980a\\n    error SF_GOV_MUST_BE_CONTRACT();                        // 0x80dddd73\\n\\n    /**\\n     * @dev Replace the current governance with a new governance\\n     */\\n    function replaceGovernance(\\n        ISuperfluid host,\\n        address newGov) external;\\n\\n    /**\\n     * @dev Register a new agreement class\\n     */\\n    function registerAgreementClass(\\n        ISuperfluid host,\\n        address agreementClass) external;\\n\\n    /**\\n     * @dev Update logics of the contracts\\n     *\\n     * @custom:note\\n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\\n     */\\n    function updateContracts(\\n        ISuperfluid host,\\n        address hostNewLogic,\\n        address[] calldata agreementClassNewLogics,\\n        address superTokenFactoryNewLogic,\\n        address beaconNewLogic\\n    ) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the provided logic contracts.\\n     *      Note that this is an overloaded version taking an additional argument `tokenLogics`\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens,\\n        address[] calldata tokenLogics) external;\\n\\n    /**\\n     * @dev Set configuration as address value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        address value\\n    ) external;\\n\\n    /**\\n     * @dev Set configuration as uint256 value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        uint256 value\\n    ) external;\\n\\n    /**\\n     * @dev Clear configuration\\n     */\\n    function clearConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key\\n    ) external;\\n\\n    /**\\n     * @dev Get configuration as address value\\n     */\\n    function getConfigAsAddress(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (address value);\\n\\n    /**\\n     * @dev Get configuration as uint256 value\\n     */\\n    function getConfigAsUint256(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (uint256 value);\\n\\n}\\n\",\"keccak256\":\"0x345e483e26ba79b19bce42b00e3b89f6ffdf11ba851f552e9c15b3eda1a993f1\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\n\\n/**\\n * @title Superfluid token interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidToken {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SF_TOKEN_AGREEMENT_ALREADY_EXISTS();  // 0xf05521f6\\n    error SF_TOKEN_AGREEMENT_DOES_NOT_EXIST();  // 0xdae18809\\n    error SF_TOKEN_BURN_INSUFFICIENT_BALANCE(); // 0x10ecdf44\\n    error SF_TOKEN_MOVE_INSUFFICIENT_BALANCE(); // 0x2f4cb941\\n    error SF_TOKEN_ONLY_LISTED_AGREEMENT();     // 0xc9ff6644\\n    error SF_TOKEN_ONLY_HOST();                 // 0xc51efddd\\n\\n    /**************************************************************************\\n     * Basic information\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /**\\n     * @dev Encoded liquidation type data mainly used for handling stack to deep errors\\n     *\\n     * @custom:note \\n     * - version: 1\\n     * - liquidationType key:\\n     *    - 0 = reward account receives reward (PIC period)\\n     *    - 1 = liquidator account receives reward (Pleb period)\\n     *    - 2 = liquidator account receives reward (Pirate period/bailout)\\n     */\\n    struct LiquidationTypeData {\\n        uint256 version;\\n        uint8 liquidationType;\\n    }\\n\\n    /**************************************************************************\\n     * Real-time balance functions\\n     *************************************************************************/\\n\\n    /**\\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\\n    * @param account for the query\\n    * @param timestamp Time of balance\\n    * @return availableBalance Real-time balance\\n    * @return deposit Account deposit\\n    * @return owedDeposit Account owed Deposit\\n    */\\n    function realtimeBalanceOf(\\n       address account,\\n       uint256 timestamp\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @notice Calculate the realtime balance given the current host.getNow() value\\n     * @dev realtimeBalanceOf with timestamp equals to block timestamp\\n     * @param account for the query\\n     * @return availableBalance Real-time balance\\n     * @return deposit Account deposit\\n     * @return owedDeposit Account owed Deposit\\n     */\\n    function realtimeBalanceOfNow(\\n       address account\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit,\\n            uint256 timestamp);\\n\\n    /**\\n    * @notice Check if account is critical\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @param timestamp The time we'd like to check if the account is critical (should use future)\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCritical(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n    * @notice Check if account is critical now (current host.getNow())\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCriticalNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n     * @notice Check if account is solvent\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @param timestamp The time we'd like to check if the account is solvent (should use future)\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolvent(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n     * @notice Check if account is solvent now\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolventNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n    * @notice Get a list of agreements that is active for the account\\n    * @dev An active agreement is one that has state for the account\\n    * @param account Account to query\\n    * @return activeAgreements List of accounts that have non-zero states for the account\\n    */\\n    function getAccountActiveAgreements(address account)\\n       external view\\n       returns(ISuperAgreement[] memory activeAgreements);\\n\\n\\n   /**************************************************************************\\n    * Super Agreement hosting functions\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function createAgreement(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement created event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementCreated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Get data of the agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @return data Data of the agreement\\n     */\\n    function getAgreementData(\\n        address agreementClass,\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external view\\n        returns(bytes32[] memory data);\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function updateAgreementData(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementUpdated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Close the agreement\\n     * @param id Agreement ID\\n     */\\n    function terminateAgreement(\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external;\\n    /**\\n     * @dev Agreement terminated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     */\\n    event AgreementTerminated(\\n        address indexed agreementClass,\\n        bytes32 id\\n    );\\n\\n    /**\\n     * @dev Update agreement state slot\\n     * @param account Account to be updated\\n     *\\n     * @custom:note \\n     * - To clear the storage out, provide zero-ed array of intended length\\n     */\\n    function updateAgreementStateSlot(\\n        address account,\\n        uint256 slotId,\\n        bytes32[] calldata slotData\\n    )\\n        external;\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account updated\\n     * @param slotId slot id of the agreement state\\n     */\\n    event AgreementStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        uint256 slotId\\n    );\\n\\n    /**\\n     * @dev Get data of the slot of the state of an agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account to query\\n     * @param slotId slot id of the state\\n     * @param dataLength length of the state data\\n     */\\n    function getAgreementStateSlot(\\n        address agreementClass,\\n        address account,\\n        uint256 slotId,\\n        uint dataLength\\n    )\\n        external view\\n        returns (bytes32[] memory slotData);\\n\\n    /**\\n     * @notice Settle balance from an account by the agreement\\n     * @dev The agreement needs to make sure that the balance delta is balanced afterwards\\n     * @param account Account to query.\\n     * @param delta Amount of balance delta to be settled\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function settleBalance(\\n        address account,\\n        int256 delta\\n    )\\n        external;\\n\\n    /**\\n     * @dev Make liquidation payouts (v2)\\n     * @param id Agreement ID\\n     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount\\n     * @param targetAccount Account to be liquidated\\n     * @param rewardAmount The amount the rewarded account will receive\\n     * @param targetAccountBalanceDelta The delta amount the target account balance should change by\\n     *\\n     * @custom:note \\n     * - If a bailout is required (bailoutAmount > 0)\\n     *   - the actual reward (single deposit) goes to the executor,\\n     *   - while the reward account becomes the bailout account\\n     *   - total bailout include: bailout amount + reward amount\\n     *   - the targetAccount will be bailed out\\n     * - If a bailout is not required\\n     *   - the targetAccount will pay the rewardAmount\\n     *   - the liquidator (reward account in PIC period) will receive the rewardAmount\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function makeLiquidationPayoutsV2\\n    (\\n        bytes32 id,\\n        bytes memory liquidationTypeData,\\n        address liquidatorAccount,\\n        bool useDefaultRewardAccount,\\n        address targetAccount,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta\\n    ) external;\\n    /**\\n     * @dev Agreement liquidation event v2 (including agent account)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param targetAccount Account of the stream sender\\n     * @param rewardAmountReceiver Account that collects the reward or bails out insolvent accounts\\n     * @param rewardAmount The amount the reward recipient account balance should change by\\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\\n     * @param liquidationTypeData The encoded liquidation type data including the version (how to decode)\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if the agreement is liquidated during the PIC period\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit), regardless of the liquidatorAccount\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the agreement is liquidated after the PIC period AND the targetAccount is solvent\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit)\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the targetAccount is insolvent\\n     *   - the liquidatorAccount will get the rewardAmount (single deposit)\\n     *   - the default reward account (governance) will pay for both the rewardAmount and bailoutAmount\\n     *   - the targetAccount will receive the bailoutAmount\\n     */\\n    event AgreementLiquidatedV2(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed liquidatorAccount,\\n        address indexed targetAccount,\\n        address rewardAmountReceiver,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta,\\n        bytes liquidationTypeData\\n    );\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * NOTE: solidity-coverage not supporting it\\n     *************************************************************************/\\n\\n     /// @dev The msg.sender must be host contract\\n     //modifier onlyHost() virtual;\\n\\n    /// @dev The msg.sender must be a listed agreement.\\n    //modifier onlyAgreement() virtual;\\n\\n    /**************************************************************************\\n     * DEPRECATED\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAccount Account that collect the reward\\n     * @param rewardAmount Amount of liquidation reward\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event AgreementLiquidated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed rewardAccount,\\n        uint256 rewardAmount\\n    );\\n\\n    /**\\n     * @dev System bailout occurred (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param bailoutAccount Account that bailout the penalty account\\n     * @param bailoutAmount Amount of account bailout\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event Bailout(\\n        address indexed bailoutAccount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedV2)\\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param bondAccount Account that collect the reward or bailout accounts\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of liquidation bailouot\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if bailout is equal to 0, then\\n     *   - the bondAccount will get the rewardAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount.\\n     * - if bailout is larger than 0, then\\n     *   - the liquidatorAccount will get the rewardAmouont,\\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\\n     */\\n    event AgreementLiquidatedBy(\\n        address liquidatorAccount,\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed bondAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    );\\n}\\n\",\"keccak256\":\"0x18ea972421ff57ce62103f90c820ee039f170f0189a4b3c73fd0ff09452d1dbf\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.11;\\n\\nimport { ISuperToken } from \\\"../superfluid/ISuperToken.sol\\\";\\n\\n\\n/**\\n * @title Super ETH (SETH) custom token interface\\n * @author Superfluid\\n */\\ninterface ISETHCustom {\\n    // using native token\\n    function upgradeByETH() external payable;\\n    function upgradeByETHTo(address to) external payable;\\n    function downgradeToETH(uint wad) external;\\n}\\n\\n/**\\n * @title Super ETH (SETH) full interface\\n * @author Superfluid\\n */\\n// solhint-disable-next-line no-empty-blocks\\ninterface ISETH is ISETHCustom, ISuperToken {}\\n\",\"keccak256\":\"0x9857ab20198ca28d75afcf2f6843a23a1052bf2199a308392f8e2d8a63914cbc\",\"license\":\"MIT\"},\"contracts/FlowSender.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.23;\\n\\nimport {ISuperfluid, ISuperToken} from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\nimport {SuperTokenV1Library} from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IFlowSender} from \\\"./IFlowSender.sol\\\";\\n\\ninterface IFakeDAI is IERC20, IFlowSender {\\n    function mint(address account, uint256 amount) external;\\n}\\n\\ncontract FlowSender {\\n    using SuperTokenV1Library for ISuperToken;\\n\\n    mapping(address => bool) public accountList;\\n    mapping(address => ISuperToken) public superTokens;\\n\\n    constructor(address[] memory tokenAddresses) {\\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\\n            superTokens[tokenAddresses[i]] = ISuperToken(tokenAddresses[i]);\\n        }\\n    }\\n\\n    /// @dev Wraps the underlying token into its SuperToken equivalent\\n    function gainWrapToken(address tokenAddress, uint256 amount) external {\\n        ISuperToken token = superTokens[tokenAddress];\\n        if (address(token) == address(0)) revert IFlowSender.InvalidTokenAddress();\\n\\n        token.upgrade(amount);\\n        emit IFlowSender.TokenWrapped(tokenAddress, amount);\\n    }\\n\\n    /// @dev creates a stream from this contract to desired receiver at desired rate\\n    function createStream(address tokenAddress, int96 flowRate, address receiver) external {\\n        ISuperToken token = superTokens[tokenAddress];\\n        if (address(token) == address(0)) revert IFlowSender.InvalidTokenAddress();\\n\\n        token.createFlow(receiver, flowRate);\\n        emit IFlowSender.StreamCreated(tokenAddress, flowRate, receiver);\\n    }\\n\\n    /// @dev updates a stream from this contract to desired receiver to desired rate\\n    function updateStream(address tokenAddress, int96 flowRate, address receiver) external {\\n        ISuperToken token = superTokens[tokenAddress];\\n        if (address(token) == address(0)) revert IFlowSender.InvalidTokenAddress();\\n\\n        token.updateFlow(receiver, flowRate);\\n        emit IFlowSender.StreamUpdated(tokenAddress, flowRate, receiver);\\n    }\\n\\n    /// @dev deletes a stream from this contract to desired receiver\\n    function deleteStream(address tokenAddress, address receiver) external {\\n        ISuperToken token = superTokens[tokenAddress];\\n        if (address(token) == address(0)) revert IFlowSender.InvalidTokenAddress();\\n\\n        token.deleteFlow(address(this), receiver);\\n        emit IFlowSender.StreamDeleted(tokenAddress, receiver);\\n    }\\n\\n    /// @dev get flow rate between this contract to certain receiver\\n    function readFlowRate(address tokenAddress, address receiver) external view returns (int96 flowRate) {\\n        ISuperToken token = superTokens[tokenAddress];\\n        if (address(token) == address(0)) revert IFlowSender.InvalidTokenAddress();\\n\\n        return token.getFlowRate(address(this), receiver);\\n    }\\n}\\n\",\"keccak256\":\"0x9a5ff4f17b1df2f75412ee99b46e20a24a517dbaa942e4ad3114ffd62924e6c5\",\"license\":\"Unlicensed\"},\"contracts/IFlowSender.sol\":{\"content\":\"\\n//SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.23;\\n\\nimport {ISuperToken} from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\n\\ninterface IFlowSender {\\n    event TokenWrapped(address indexed tokenAddress, uint256 amount);\\n    event StreamCreated(address indexed tokenAddress, int96 flowRate, address indexed receiver);\\n    event StreamUpdated(address indexed tokenAddress, int96 flowRate, address indexed receiver);\\n    event StreamDeleted(address indexed tokenAddress, address indexed receiver);\\n\\n    error InvalidTokenAddress();\\n\\n    function accountList(address account) external view returns (bool);\\n    function superTokens(address tokenAddress) external view returns (ISuperToken);\\n\\n    function gainWrapToken(address tokenAddress, uint256 amount) external;\\n    function createStream(address tokenAddress, int96 flowRate, address receiver) external;\\n    function updateStream(address tokenAddress, int96 flowRate, address receiver) external;\\n    function deleteStream(address tokenAddress, address receiver) external;\\n    function readFlowRate(address tokenAddress, address receiver) external view returns (int96 flowRate);\\n}\\n\",\"keccak256\":\"0x603ce811782a7c7e6dad456cdd0272b033caac3d5a996f8611812f726ef7ca08\",\"license\":\"Unlicensed\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b5060405162000fd738038062000fd78339810160408190526200003491620000f7565b60005b8151811015620000bc57818181518110620000565762000056620001c9565b602002602001015160016000848481518110620000775762000077620001c9565b6020908102919091018101516001600160a01b0390811683529082019290925260400160002080546001600160a01b0319169290911691909117905560010162000037565b5050620001df565b634e487b7160e01b600052604160045260246000fd5b80516001600160a01b0381168114620000f257600080fd5b919050565b600060208083850312156200010b57600080fd5b82516001600160401b03808211156200012357600080fd5b818501915085601f8301126200013857600080fd5b8151818111156200014d576200014d620000c4565b8060051b604051601f19603f83011681018181108582111715620001755762000175620000c4565b6040529182528482019250838101850191888311156200019457600080fd5b938501935b82851015620001bd57620001ad85620000da565b8452938501939285019262000199565b98975050505050505050565b634e487b7160e01b600052603260045260246000fd5b610de880620001ef6000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063aa67a53e1161005b578063aa67a53e146100f0578063d1739c7514610103578063d3a07fcd14610116578063d53dab251461014957600080fd5b80633698d1771461008257806364ea1c3d146100975780636c868884146100dd575b600080fd5b610095610090366004610ab0565b61016f565b005b6100c06100a5366004610afb565b6001602052600090815260409020546001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6100956100eb366004610b1f565b61020b565b6100956100fe366004610b4b565b6102e6565b610095610111366004610ab0565b610379565b610139610124366004610afb565b60006020819052908152604090205460ff1681565b60405190151581526020016100d4565b61015c610157366004610b4b565b61040b565b604051600b9190910b81526020016100d4565b6001600160a01b0380841660009081526001602052604090205416806101a857604051630f58058360e11b815260040160405180910390fd5b6101bc6001600160a01b0382168385610462565b50604051600b84900b81526001600160a01b0380841691908616907f5cd1ca4c52466f80ea47d8003dd290a35dd46207d6841f90c3a050c762ae06c0906020015b60405180910390a350505050565b6001600160a01b03808316600090815260016020526040902054168061024457604051630f58058360e11b815260040160405180910390fd5b6040516345977d0360e01b8152600481018390526001600160a01b038216906345977d0390602401600060405180830381600087803b15801561028657600080fd5b505af115801561029a573d6000803e3d6000fd5b50505050826001600160a01b03167f2273a99739c31a37346636a3013c2cedebee7cd5b4c560faded39d298c1dd45c836040516102d991815260200190565b60405180910390a2505050565b6001600160a01b03808316600090815260016020526040902054168061031f57604051630f58058360e11b815260040160405180910390fd5b6103336001600160a01b0382163084610481565b50816001600160a01b0316836001600160a01b03167f732309c7ef763aa1f86535c7e65161ed3bf7a22da9e654bf554ea1178a1aeb0960405160405180910390a3505050565b6001600160a01b0380841660009081526001602052604090205416806103b257604051630f58058360e11b815260040160405180910390fd5b6103c66001600160a01b03821683856104a0565b50604051600b84900b81526001600160a01b0380841691908616907fa92bc119ff2dc5de2d388c587c8077e6ced8fd650dacbd1c69fcc6a0aeea388e906020016101fd565b6001600160a01b038083166000908152600160205260408120549091168061044657604051630f58058360e11b815260040160405180910390fd5b61045a6001600160a01b03821630856104bf565b949350505050565b6040805160008082526020820190925261045a90859085908590610557565b6040805160008082526020820190925261045a90859085908590610683565b6040805160008082526020820190925261045a9085908590859061070f565b6000806104cb8561075d565b604051631cd43d1160e31b81526001600160a01b03888116600483015287811660248301528681166044830152919350908316915063e6a1e88890606401608060405180830381865afa158015610526573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061054a9190610b9a565b5090979650505050505050565b6000806000610565876108de565b91509150816001600160a01b03166339255d5b82836001600160a01b03166362fc305e8b8b8b600067ffffffffffffffff8111156105a5576105a5610b84565b6040519080825280601f01601f1916602001820160405280156105cf576020820181803683370190505b506040516024016105e39493929190610c28565b60408051808303601f1901815291815260208201805160e094851b6001600160e01b03909116179052519185901b6001600160e01b031916825261062e939250908990600401610c68565b6000604051808303816000875af115801561064d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106759190810190610c9e565b506001979650505050505050565b6000806000610691876108de565b91509150816001600160a01b03166339255d5b82836001600160a01b031663b4b333c68b8b8b600067ffffffffffffffff8111156106d1576106d1610b84565b6040519080825280601f01601f1916602001820160405280156106fb576020820181803683370190505b506040516024016105e39493929190610d4b565b600080600061071d876108de565b91509150816001600160a01b03166339255d5b82836001600160a01b03166350209a628b8b8b600067ffffffffffffffff8111156105a5576105a5610b84565b7f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837547fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a546001600160a01b0381166108ad576001600160a01b03821661082257826001600160a01b03166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081f9190610d7f565b91505b604051635b69006f60e11b81527fa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd360048201526001600160a01b0383169063b6d200de90602401602060405180830381865afa158015610886573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108aa9190610d7f565b90505b6001600160a01b0382166108c3576108c3610d9c565b6001600160a01b0381166108d9576108d9610d9c565b915091565b7f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837547fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a546001600160a01b0381166108ad576001600160a01b0382166109a357826001600160a01b03166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa15801561097c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109a09190610d7f565b91505b604051635b69006f60e11b81527fa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd360048201526001600160a01b0383169063b6d200de90602401602060405180830381865afa158015610a07573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a2b9190610d7f565b9050817f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea83755807fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a556001600160a01b0382166108c3576108c3610d9c565b6001600160a01b0381168114610a9e57600080fd5b50565b80600b0b8114610a9e57600080fd5b600080600060608486031215610ac557600080fd5b8335610ad081610a89565b92506020840135610ae081610aa1565b91506040840135610af081610a89565b809150509250925092565b600060208284031215610b0d57600080fd5b8135610b1881610a89565b9392505050565b60008060408385031215610b3257600080fd5b8235610b3d81610a89565b946020939093013593505050565b60008060408385031215610b5e57600080fd5b8235610b6981610a89565b91506020830135610b7981610a89565b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b60008060008060808587031215610bb057600080fd5b845193506020850151610bc281610aa1565b6040860151606090960151949790965092505050565b60005b83811015610bf3578181015183820152602001610bdb565b50506000910152565b60008151808452610c14816020860160208601610bd8565b601f01601f19169290920160200192915050565b6001600160a01b03858116825284166020820152600b83900b6040820152608060608201819052600090610c5e90830184610bfc565b9695505050505050565b6001600160a01b0384168152606060208201819052600090610c8c90830185610bfc565b8281036040840152610c5e8185610bfc565b600060208284031215610cb057600080fd5b815167ffffffffffffffff80821115610cc857600080fd5b818401915084601f830112610cdc57600080fd5b815181811115610cee57610cee610b84565b604051601f8201601f19908116603f01168101908382118183101715610d1657610d16610b84565b81604052828152876020848701011115610d2f57600080fd5b610d40836020830160208801610bd8565b979650505050505050565b6001600160a01b038581168252848116602083015283166040820152608060608201819052600090610c5e90830184610bfc565b600060208284031215610d9157600080fd5b8151610b1881610a89565b634e487b7160e01b600052600160045260246000fdfea26469706673582212201cfb03d6f9cb08cf853f511d76ec7ce97033c3618f73db93a01e067bd7d9b51264736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063aa67a53e1161005b578063aa67a53e146100f0578063d1739c7514610103578063d3a07fcd14610116578063d53dab251461014957600080fd5b80633698d1771461008257806364ea1c3d146100975780636c868884146100dd575b600080fd5b610095610090366004610ab0565b61016f565b005b6100c06100a5366004610afb565b6001602052600090815260409020546001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6100956100eb366004610b1f565b61020b565b6100956100fe366004610b4b565b6102e6565b610095610111366004610ab0565b610379565b610139610124366004610afb565b60006020819052908152604090205460ff1681565b60405190151581526020016100d4565b61015c610157366004610b4b565b61040b565b604051600b9190910b81526020016100d4565b6001600160a01b0380841660009081526001602052604090205416806101a857604051630f58058360e11b815260040160405180910390fd5b6101bc6001600160a01b0382168385610462565b50604051600b84900b81526001600160a01b0380841691908616907f5cd1ca4c52466f80ea47d8003dd290a35dd46207d6841f90c3a050c762ae06c0906020015b60405180910390a350505050565b6001600160a01b03808316600090815260016020526040902054168061024457604051630f58058360e11b815260040160405180910390fd5b6040516345977d0360e01b8152600481018390526001600160a01b038216906345977d0390602401600060405180830381600087803b15801561028657600080fd5b505af115801561029a573d6000803e3d6000fd5b50505050826001600160a01b03167f2273a99739c31a37346636a3013c2cedebee7cd5b4c560faded39d298c1dd45c836040516102d991815260200190565b60405180910390a2505050565b6001600160a01b03808316600090815260016020526040902054168061031f57604051630f58058360e11b815260040160405180910390fd5b6103336001600160a01b0382163084610481565b50816001600160a01b0316836001600160a01b03167f732309c7ef763aa1f86535c7e65161ed3bf7a22da9e654bf554ea1178a1aeb0960405160405180910390a3505050565b6001600160a01b0380841660009081526001602052604090205416806103b257604051630f58058360e11b815260040160405180910390fd5b6103c66001600160a01b03821683856104a0565b50604051600b84900b81526001600160a01b0380841691908616907fa92bc119ff2dc5de2d388c587c8077e6ced8fd650dacbd1c69fcc6a0aeea388e906020016101fd565b6001600160a01b038083166000908152600160205260408120549091168061044657604051630f58058360e11b815260040160405180910390fd5b61045a6001600160a01b03821630856104bf565b949350505050565b6040805160008082526020820190925261045a90859085908590610557565b6040805160008082526020820190925261045a90859085908590610683565b6040805160008082526020820190925261045a9085908590859061070f565b6000806104cb8561075d565b604051631cd43d1160e31b81526001600160a01b03888116600483015287811660248301528681166044830152919350908316915063e6a1e88890606401608060405180830381865afa158015610526573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061054a9190610b9a565b5090979650505050505050565b6000806000610565876108de565b91509150816001600160a01b03166339255d5b82836001600160a01b03166362fc305e8b8b8b600067ffffffffffffffff8111156105a5576105a5610b84565b6040519080825280601f01601f1916602001820160405280156105cf576020820181803683370190505b506040516024016105e39493929190610c28565b60408051808303601f1901815291815260208201805160e094851b6001600160e01b03909116179052519185901b6001600160e01b031916825261062e939250908990600401610c68565b6000604051808303816000875af115801561064d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106759190810190610c9e565b506001979650505050505050565b6000806000610691876108de565b91509150816001600160a01b03166339255d5b82836001600160a01b031663b4b333c68b8b8b600067ffffffffffffffff8111156106d1576106d1610b84565b6040519080825280601f01601f1916602001820160405280156106fb576020820181803683370190505b506040516024016105e39493929190610d4b565b600080600061071d876108de565b91509150816001600160a01b03166339255d5b82836001600160a01b03166350209a628b8b8b600067ffffffffffffffff8111156105a5576105a5610b84565b7f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837547fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a546001600160a01b0381166108ad576001600160a01b03821661082257826001600160a01b03166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081f9190610d7f565b91505b604051635b69006f60e11b81527fa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd360048201526001600160a01b0383169063b6d200de90602401602060405180830381865afa158015610886573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108aa9190610d7f565b90505b6001600160a01b0382166108c3576108c3610d9c565b6001600160a01b0381166108d9576108d9610d9c565b915091565b7f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837547fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a546001600160a01b0381166108ad576001600160a01b0382166109a357826001600160a01b03166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa15801561097c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109a09190610d7f565b91505b604051635b69006f60e11b81527fa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd360048201526001600160a01b0383169063b6d200de90602401602060405180830381865afa158015610a07573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a2b9190610d7f565b9050817f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea83755807fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a556001600160a01b0382166108c3576108c3610d9c565b6001600160a01b0381168114610a9e57600080fd5b50565b80600b0b8114610a9e57600080fd5b600080600060608486031215610ac557600080fd5b8335610ad081610a89565b92506020840135610ae081610aa1565b91506040840135610af081610a89565b809150509250925092565b600060208284031215610b0d57600080fd5b8135610b1881610a89565b9392505050565b60008060408385031215610b3257600080fd5b8235610b3d81610a89565b946020939093013593505050565b60008060408385031215610b5e57600080fd5b8235610b6981610a89565b91506020830135610b7981610a89565b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b60008060008060808587031215610bb057600080fd5b845193506020850151610bc281610aa1565b6040860151606090960151949790965092505050565b60005b83811015610bf3578181015183820152602001610bdb565b50506000910152565b60008151808452610c14816020860160208601610bd8565b601f01601f19169290920160200192915050565b6001600160a01b03858116825284166020820152600b83900b6040820152608060608201819052600090610c5e90830184610bfc565b9695505050505050565b6001600160a01b0384168152606060208201819052600090610c8c90830185610bfc565b8281036040840152610c5e8185610bfc565b600060208284031215610cb057600080fd5b815167ffffffffffffffff80821115610cc857600080fd5b818401915084601f830112610cdc57600080fd5b815181811115610cee57610cee610b84565b604051601f8201601f19908116603f01168101908382118183101715610d1657610d16610b84565b81604052828152876020848701011115610d2f57600080fd5b610d40836020830160208801610bd8565b979650505050505050565b6001600160a01b038581168252848116602083015283166040820152608060608201819052600090610c5e90830184610bfc565b600060208284031215610d9157600080fd5b8151610b1881610a89565b634e487b7160e01b600052600160045260246000fdfea26469706673582212201cfb03d6f9cb08cf853f511d76ec7ce97033c3618f73db93a01e067bd7d9b51264736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createStream(address,int96,address)": {
        "details": "creates a stream from this contract to desired receiver at desired rate"
      },
      "deleteStream(address,address)": {
        "details": "deletes a stream from this contract to desired receiver"
      },
      "gainWrapToken(address,uint256)": {
        "details": "Wraps the underlying token into its SuperToken equivalent"
      },
      "readFlowRate(address,address)": {
        "details": "get flow rate between this contract to certain receiver"
      },
      "updateStream(address,int96,address)": {
        "details": "updates a stream from this contract to desired receiver to desired rate"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 12040,
        "contract": "contracts/FlowSender.sol:FlowSender",
        "label": "accountList",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 12045,
        "contract": "contracts/FlowSender.sol:FlowSender",
        "label": "superTokens",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_contract(ISuperToken)10730)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(ISuperToken)10730": {
        "encoding": "inplace",
        "label": "contract ISuperToken",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_contract(ISuperToken)10730)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => contract ISuperToken)",
        "numberOfBytes": "32",
        "value": "t_contract(ISuperToken)10730"
      }
    }
  }
}